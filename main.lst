CCS PCD C Compiler, Version 5.074, 43599               26-júl.-18 20:25

               Filename:   C:\Users\Benjamin\MPLABXProjects\EcgFirmware.X\main.lst

               ROM used:   7132 bytes (4%)
                           Largest free fragment is 65536
               RAM used:   13848 (48%) at main() level
                           13926 (49%) worst case
               Stack used: 90 locations (26 in main + 64 for interrupts)
               Stack size: 128

*
00000:  GOTO    17BA
*
000C0:  DATA    D6,13,00
.................... /*  
....................  * File:   main.c 
....................  * Author: Benjamin 
....................  * 
....................  * Created on 2018. május 21., 11:31 
....................  */ 
.................... #include <main.h> 
.................... #include <33EP256MU806.h> 
.................... //////////// Standard Header file for the DSPIC33EP256MU806 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC33EP256MU806 
*
00200:  CLR     54
00202:  MOV     #20C,W3
00204:  ADD     W3,W0,W0
00206:  TBLRDL.B[W0],W0L
00208:  CLR.B   1
0020A:  RETURN  
0020C:  DATA    00,03,00
0020E:  DATA    02,FF,00
00210:  DATA    FF,FF,00
00212:  DATA    FF,FF,00
00214:  DATA    FF,FF,00
00216:  DATA    FF,FF,00
00218:  DATA    FF,FF,00
0021A:  DATA    FF,FF,00
0021C:  CLR     54
0021E:  MOV     #228,W3
00220:  ADD     W3,W0,W0
00222:  TBLRDL.B[W0],W0L
00224:  CLR.B   1
00226:  RETURN  
00228:  DATA    00,FF,00
0022A:  DATA    02,FF,00
0022C:  DATA    FF,FF,00
0022E:  DATA    FF,FF,00
00230:  DATA    FF,FF,00
00232:  DATA    FF,FF,00
00234:  DATA    FF,FF,00
00236:  DATA    FF,FF,00
00238:  CLR     54
0023A:  MOV     #242,W3
0023C:  ADD     W3,W0,W0
0023E:  TBLRDL  [W0],W0
00240:  RETURN  
00242:  DATA    40,00,00
00244:  DATA    0B,00,00
00246:  DATA    40,00,00
00248:  DATA    00,00,00
0024A:  DATA    00,00,00
0024C:  DATA    00,00,00
0024E:  DATA    00,00,00
00250:  DATA    00,00,00
00252:  DATA    00,00,00
00254:  DATA    00,00,00
00256:  DATA    00,00,00
00258:  DATA    00,00,00
0025A:  DATA    00,00,00
0025C:  DATA    00,00,00
0025E:  DATA    00,00,00
00260:  DATA    00,00,00
00262:  CLR     54
00264:  MOV     #26C,W3
00266:  ADD     W3,W0,W0
00268:  TBLRDL  [W0],W0
0026A:  RETURN  
0026C:  DATA    40,00,00
0026E:  DATA    00,00,00
00270:  DATA    40,00,00
00272:  DATA    00,00,00
00274:  DATA    00,00,00
00276:  DATA    00,00,00
00278:  DATA    00,00,00
0027A:  DATA    00,00,00
0027C:  DATA    00,00,00
0027E:  DATA    00,00,00
00280:  DATA    00,00,00
00282:  DATA    00,00,00
00284:  DATA    00,00,00
00286:  DATA    00,00,00
00288:  DATA    00,00,00
0028A:  DATA    00,00,00
0028C:  CLR     54
0028E:  MOV     #2E,W3
00290:  SUB     W0,W3,W3
00292:  BRA     C,29E
00294:  MOV     #2A8,W3
00296:  ADD     W3,W0,W0
00298:  TBLRDL.B[W0],W0L
0029A:  CLR.B   1
0029C:  RETURN  
0029E:  MOV     #2A8,W0
002A0:  ADD     W3,W3,W3
002A2:  ADD     W3,W0,W3
002A4:  TBLRDH  [W3],W0
002A6:  RETURN  
002A8:  DATA    09,02,01
002AA:  DATA    43,00,00
002AC:  DATA    02,01,02
002AE:  DATA    00,80,0A
002B0:  DATA    32,09,00
002B2:  DATA    04,00,00
002B4:  DATA    00,01,00
002B6:  DATA    02,02,07
002B8:  DATA    01,00,05
002BA:  DATA    05,24,02
002BC:  DATA    00,10,02
002BE:  DATA    01,04,40
002C0:  DATA    24,02,00
002C2:  DATA    02,05,01
002C4:  DATA    24,06,07
002C6:  DATA    00,01,05
002C8:  DATA    05,24,82
002CA:  DATA    01,00,02
002CC:  DATA    01,07,40
002CE:  DATA    05,81,00
002D0:  DATA    03,0B,01
002D2:  DATA    00,FA,00
002D4:  DATA    09,04,00
002D6:  CLR     54
002D8:  MOV     #2E2,W3
002DA:  ADD     W3,W0,W0
002DC:  TBLRDL.B[W0],W0L
002DE:  CLR.B   1
002E0:  RETURN  
002E2:  DATA    02,00,00
002E4:  CLR     54
002E6:  MOV     #2F0,W3
002E8:  ADD     W3,W0,W0
002EA:  TBLRDL.B[W0],W0L
002EC:  CLR.B   1
002EE:  RETURN  
002F0:  DATA    12,17,00
002F2:  DATA    1B,20,00
002F4:  DATA    FF,FF,00
002F6:  DATA    FF,FF,00
002F8:  CLR     54
002FA:  MOV     #304,W3
002FC:  ADD     W3,W0,W0
002FE:  TBLRDL.B[W0],W0L
00300:  CLR.B   1
00302:  RETURN  
00304:  DATA    12,01,00
00306:  DATA    10,01,00
00308:  DATA    02,00,00
0030A:  DATA    00,40,00
0030C:  DATA    05,24,00
0030E:  DATA    0B,00,00
00310:  DATA    00,01,00
00312:  DATA    01,02,00
00314:  DATA    00,01,00
00316:  CLR     54
00318:  MOV     #1E,W3
0031A:  SUB     W0,W3,W3
0031C:  BRA     C,328
0031E:  MOV     #332,W3
00320:  ADD     W3,W0,W0
00322:  TBLRDL.B[W0],W0L
00324:  CLR.B   1
00326:  RETURN  
00328:  MOV     #332,W0
0032A:  ADD     W3,W3,W3
0032C:  ADD     W3,W0,W3
0032E:  TBLRDH  [W3],W0
00330:  RETURN  
00332:  DATA    04,03,74
00334:  DATA    09,04,00
00336:  DATA    08,03,6F
00338:  DATA    43,00,00
0033A:  DATA    43,00,20
0033C:  DATA    53,00,00
0033E:  DATA    20,03,55
00340:  DATA    43,00,00
00342:  DATA    43,00,41
00344:  DATA    53,00,00
00346:  DATA    20,00,52
00348:  DATA    55,00,00
0034A:  DATA    53,00,54
0034C:  DATA    42,00,00
0034E:  DATA    20,00,00
....................  
.................... #list 
....................  
.................... #device ICSP=1 
.................... #device *=16 
.................... //#use delay(clock=140000000,crystal=16000000,USB_FULL,AUX:clock=48000000) 
.................... #use delay(clock=140MHz,crystal=16MHz, USB_FULL, AUX:clock=48MHz/*,crystal=16MHz*/) 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES CKSFSM                   //Clock Switching is enabled, fail Safe clock monitor is enabled 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOJTAG                   //JTAG disabled 
.................... #FUSES ICSP1 
.................... #FUSES NODEBUG 
....................  
.................... #define PIC_16BIT 
.................... #include <MyTypes.h> 
.................... /*  
....................  * File:   MyTypes.h 
....................  * Author: Benjamin Bodnár 
....................  * 
....................  * Created on 2018. június 30., 15:09 
....................  */ 
....................  
.................... #ifndef MYTYPES_H 
.................... #define	MYTYPES_H 
....................  
.................... #define TRUE    1 
.................... #define FALSE   0 
....................  
.................... #ifdef PIC_16BIT 
.................... typedef unsigned char       uint8; 
.................... typedef unsigned int        uint16; 
.................... typedef unsigned long       uint32; 
.................... typedef unsigned long long  uint64; 
.................... typedef signed char         sint8; 
.................... typedef signed int          sint16; 
.................... typedef signed long         sint32; 
.................... typedef signed long         sint64; 
.................... //typedef unsigned char       boolean; 
.................... #endif 
....................  
.................... #endif	/* MYTYPES_H */ 
....................  
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'ptr' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putd(*ptr, len) - Sends 'len' byte from 'ptr' to the    //// 
.................... ////     transmit buffer.  Unlike usb_cdc_putc() or                  //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////     'len' needs to be smaller than the transmit buffer.         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns the number of bytes available      //// 
.................... ////     in the TX buffer for storing characters.  If this returns   //// 
.................... ////     0 then the buffer is full and waiting for the host (PC)     //// 
.................... ////     to read the buffer.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   //// 
.................... ////     empty and fully flushed/transmitted to host (PC).           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          //// 
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   //// 
.................... ////       ring, break and more.  See the documentation above        //// 
.................... ////       usb_cdc_serial_state() for more information, including    //// 
.................... ////       format of state structure.                                //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// USB_CDC_ISR() can be defined if you want a specific routine to  //// 
.................... //// be called when there is incoming CDC (virtual com port) data.   //// 
.................... //// This is useful if you want to update legacy RS232 code that     //// 
.................... //// was using #int_rda to handle incoming data in the RS232 ISR.    //// 
.................... //// However, see the INTERRUPT LIMITATIONS section below.           //// 
.................... ////                                                                 //// 
.................... //// Normally usb_cdc_putc() and usb_cdc_putc_fast() will attempt    //// 
.................... ////  to flush the data as soon as possible.  However at times       //// 
.................... ////  this can be ineffecient and flush a packet with only 1 byte.   //// 
.................... ////  The USB_CDC_DELAYED_FLUSH option will attempt to flush         //// 
.................... ////  at the beginning of usb_cdc_putc() and usb_cdc_putc_fast()     //// 
.................... ////  if the local buffer is full.  USB_CDC_DELAYED_FLUSH will       //// 
.................... ////  also attempt to flush the packet on each call to usb_task().   //// 
.................... ////  It is recommended to only use USB_CDC_DELAYED_FLUSH option     //// 
.................... ////  if you have a main loop that periodically calls usb_task().    //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// Encapsuated Messages: (USB_CDC_USE_ENCAPSULATED)                //// 
.................... //// -------------------------------------------------------------   //// 
.................... ////                                                                 //// 
.................... //// If USB_CDC_USE_ENCAPSULATED is defined, then the user must      //// 
.................... //// provide the following callbacks in their application to provide //// 
.................... //// encapsuated message support (SendEncapsulatedCommand and        //// 
.................... ////  GetEncapsulatedResponse):                                      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_SendEncapsulatedCommand(byte *ptr, unsigned int16 num)  //// 
.................... ////     PIC receives encapsulated command from host (PC), 'num'     //// 
.................... ////     bytes of message stored in 'ptr'.                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_GetEncapsulatedResponse(byte *ptr, unsigned int16 num)  //// 
.................... ////     Host (PC) is asking for 'num' bytes response from the PIC,  //// 
.................... ////     PIC should store up to 'num' bytes to 'ptr' as the          //// 
.................... ////     response.                                                   //// 
.................... ////                                                                 //// 
.................... //// Due to the design of the USB stack, all encapsulated messages   //// 
.................... //// must be smaller than one endpoint 0 packet.  They cannot be     //// 
.................... //// equal in size or larger than the endpoint 0 size.  See          //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH.                                      //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// BUFFER SIZES                                                    //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// USB_CDC_DATA_IN_SIZE controls the PIC->PC buffer size.  The     //// 
.................... ////  total buffer size will be ((USB_CDC_DATA_IN_SIZE*2)-1).        //// 
.................... ////  Full speed devices limit this value to be 64.  To increase     //// 
.................... ////  the size of the local PIC buffer you can also define           //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE.  If USB_CDC_DATA_LOCAL_SIZE is        //// 
.................... ////  defined then the total PIC->PC buffer size would be            //// 
.................... ////  USB_CDC_DATA_LOCAL_SIZE+USB_CDC_DATA_IN_SIZE.                  //// 
.................... ////  If USB_CDC_DATA_IN_SIZE is not defined, the default value      //// 
.................... ////  of 64 is used.  If USB_CDC_DATA_LOCAL_SIZE is not defined      //// 
.................... ////  then this option isn't used.                                   //// 
.................... ////                                                                 //// 
.................... ////                                                                 //// 
.................... //// INTERRUPT LIMITATIONS                                           //// 
.................... //// -------------------------------------------------------------   //// 
.................... //// This section is only relevant if you are using USB interrupts   //// 
.................... ////  and not the USB_ISR_POLLING option.                            //// 
.................... ////                                                                 //// 
.................... //// USB handling is complex, often requiring several packet         //// 
.................... ////  transmissions to accomplish transfer of one block of data.     //// 
.................... ////  Most of this processing is done in the USB ISR.  Because       //// 
.................... ////  of this you cannot call usb_cdc_putc() inside another ISR, the //// 
.................... ////  USB ISR or when ISRs are disabled.  To workaround this problem,   //// 
.................... ////  use usb_cdc_putc_fast() and the USB_CDC_DELAYED_FLUSH option.  //// 
.................... ////  This isn't perfect, because if you use usb_cdc_putc_fast() to  //// 
.................... ////  overflow the TX buffer than data will be lost.                 //// 
.................... ////                                                                 //// 
.................... //// You also cannot call usb_cdc_getc() inside another ISR, the USB //// 
.................... ////  ISR, USB_CDC_ISR() or when interrupts are disabled UNLESS      //// 
.................... ////  usb_cdc_kbhit() returns TRUE.  It is for this reason           //// 
.................... ////  ex_usb_serial3.c uses a statemachine for reception of data.    //// 
.................... ////                                                                 //// 
.................... //// ex_usb_serial3.c shows an example of working around these       //// 
.................... ////  ISR limitations.  Failure to follow these limitations can      //// 
.................... ////  cause the PIC to lockup.  These limtations only need to be     //// 
.................... ////  followed in the conditions listed above (writing code in the   //// 
.................... ////  ISR or interrupts are disabled).                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// Nov 20th, 2014:                                                 //// 
.................... ////  While usb_cdc_putc() waits for local buffer to be free, also   //// 
.................... ////     check the endpoint buffer in case there was a situation     //// 
.................... ////     that the ISR for this event was missed.                     //// 
.................... ////                                                                 //// 
.................... //// Dec 16th, 2013:                                                 //// 
.................... ////  Added encapsulated message support.  See                       //// 
.................... ////     USB_CDC_USE_ENCAPSULATED above for documentation.           //// 
.................... ////                                                                 //// 
.................... //// May 31st, 2013:                                                 //// 
.................... ////  usb_cdc_putready() now returns the number of bytes available.  //// 
.................... ////                                                                 //// 
.................... //// May 23rd, 2013:                                                 //// 
.................... ////  Added usb_cdc_putd().                                          //// 
.................... ////                                                                 //// 
.................... //// February 18th, 2013:                                            //// 
.................... ////  Enhanced PIC16 support added.                                  //// 
.................... ////  Added USB_CDC_ISR(), USB_CDC_DELAYED_FLUSH and                 //// 
.................... ////     USB_CDC_DATA_LOCAL_SIZE.                                    //// 
.................... ////                                                                 //// 
.................... //// September 13th, 2012:                                           //// 
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     //// 
.................... ////     (PIC24, dsPIC33).                                           //// 
.................... ////  Added usb_cdc_putempty().                                      //// 
.................... ////                                                                 //// 
.................... //// December 16th, 2011:                                            //// 
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will //// 
.................... ////     only include the get string helper functions.  This is      //// 
.................... ////     a rarely used option, used only if you already wrote your   //// 
.................... ////     own getc() and putc() routines.                             //// 
.................... ////  usb_cdc_flush_tx_buffer() checks len buffer before flushing .  //// 
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      //// 
.................... ////     usb_cdc_flush_tx_buffer() is checking len.                  //// 
.................... ////                                                                 //// 
.................... //// Oct 27th, 2011:                                                 //// 
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    //// 
.................... ////     documentation.  In order for this to work,                  //// 
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... char gethex_usb(); 
.................... char gethex1_usb(); 
....................  
.................... #if !defined(__USB_CDC_HELPERS_ONLY__) 
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free()) 
.................... #define usb_cdc_putready() (sizeof(usb_cdc_put_buffer)-usb_cdc_put_buffer_nextin) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_tx_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCM__) 
....................     #include <pic16f_usb.h>   //Microchip PIC16Fxxxx hardware layer for usb.c 
....................    #elif defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic24_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC24 family chips.          //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC24_USB_H__ 
.................... #DEFINE __PIC24_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   1 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
....................    #if !USB_USE_FULL_SPEED 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(unsigned int8 endpoint, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(unsigned int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................  
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #ifndef __USB_DESCRIPTORS__ 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Oct 27th, 2011:                                                   //// 
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     //// 
.................... ////     send SERIAL_STATE messages in one packet.                     //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #ifndef  USB_CONFIG_PID 
....................    #define  USB_CONFIG_PID       0x000b 
.................... #endif 
.................... #ifndef  USB_CONFIG_VID 
....................    #define  USB_CONFIG_VID       0x2405 
.................... #endif 
.................... #ifndef  USB_CONFIG_BUS_POWER 
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #endif 
.................... #ifndef  USB_CONFIG_VERSION 
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... #endif 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #ifndef USB_CDC_COMM_IN_SIZE 
.................... #define USB_CDC_COMM_IN_SIZE           11 
.................... #endif 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_IN_SIZE 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #endif 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_OUT_SIZE 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #endif 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          32, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'S',0, 
....................          'B',0, 
....................          ' ',0, 
....................          't',0, 
....................          'o',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'A',0, 
....................          'R',0, 
....................          'T',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 20, 2015                                                    //// 
.................... ////     USB_STRING_DESC_OFFSET no longer used.                        //// 
.................... ////                                                                   //// 
.................... //// Feb 6th, 2015                                                     //// 
.................... ////     Fixed 'len' not being intiailized in usb_gets()               //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #ifndef debug_usb_control 
....................    #define debug_usb_control(a,b,c,d,e,f,g,h,i,j,k,l,m,n) 
.................... #endif 
....................  
.................... #ifndef debug_usb_token 
....................    #define debug_usb_token(a,b,c,d,e,f,g,h,i,j,k,l,m,n) 
.................... #endif 
....................  
.................... #ifndef debug_usb_packet 
....................    #define debug_usb_packet(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) 
....................    #define debug_display_ram(len, ptr) 
.................... #else 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr)  
....................    { 
....................       while(len--) 
....................       { 
....................          debug_usb_packet(debug_putc, "%02X", *ptr++); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... // legacy 
.................... #ifndef debug_usb 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16F_USB_H__) 
....................  #include <pic16f_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic24_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic24_usb.h more     //// 
.................... //// documentation about the PIC24 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// May 13, 2016:                                                   //// 
.................... ////  Fix for non-EP chips that have UBDTP2 and UBDTP3 registers.    //// 
.................... ////                                                                 //// 
.................... //// Feb 6th, 2015:                                                  //// 
.................... ////  Added __UIDLE_JAM_ERRATA__ for dsPIC33EP/PIC24EP chips.        //// 
.................... ////                                                                 //// 
.................... //// July 23rd, 2012:                                                //// 
.................... ////  Added __STALL_ON_UEP_ERRATA__                                  //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// May 9th, 2012:                                                  //// 
.................... ////  Update to work with latest PCD compilers.                      //// 
.................... ////                                                                 //// 
.................... //// Mar 7th, 2012:                                                  //// 
.................... ////  Added 24EP/33EP family support.                                //// 
.................... ////                                                                 //// 
.................... //// Oct 10th, 2010:                                                 //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC24_USB_C__ 
.................... #DEFINE __PIC24_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (127) 
.................... #define INT8_MIN  (-128) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (127) 
.................... #define INT_LEAST8_MIN  (-128) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (127) 
.................... #define INT_FAST8_MIN  (-128) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... #if defined(__PCD__) 
....................    typedef unsigned int32 uintptr_t; 
....................    typedef signed int32 intptr_t; 
.................... #else 
....................    typedef unsigned int16 uintptr_t; 
....................    typedef signed int16 intptr_t; 
.................... #endif 
....................  
.................... /// TODO: 
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define __STALL_ON_UEP_ERRATA__ 
.................... #define __UIDLE_JAM_ERRATA__ 
....................  
.................... #if getenv("BIT_VALID:USB1IE") 
....................    #bit USBIE=getenv("BIT:USB1IE") 
.................... #else 
....................    #bit USBIE=getenv("BIT:USBIE") 
.................... #endif 
....................  
.................... #if (getenv("ENH24")) 
....................    //newer style PIC24EP/dsPIC33EP chips 
....................    #define __PIC24EP_USB__ 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > getenv("RAM")) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if defined(__PIC24EP_USB__) 
.................... #define __PIC24_NINC_BIT__ 0 
.................... typedef union 
.................... { 
....................    struct 
....................    { 
....................       unsigned int8 :2;  //reserved bits 0 and 1 of word 1 
....................       unsigned int8 pid:4; 
....................    }; 
....................    struct 
....................    { 
....................       unsigned int8 :2;     //reserved bits 0 and 1 of word 1 
....................       unsigned int8 bstall:1; 
....................       unsigned int8 dtsen:1; 
....................       unsigned int8 ninc:1; 
....................       unsigned int8 keep:1; 
....................       unsigned int8 data01:1; 
....................       unsigned int8 uown:1; 
....................       unsigned int8: 8; //reserved bits 8 to 15 of word1 
....................       unsigned int16 count; 
....................    }; 
.................... } usb_bd_stat_t; 
.................... typedef unsigned int32 usb_bd_ptr_t; 
.................... #else 
.................... #if defined(__PIC24_NINC_BIT__) 
.................... #undef __PIC24_NINC_BIT__ 
.................... #endif 
.................... #define __PIC24_NINC_BIT__ 0 
.................... //pic24f 
.................... typedef union 
.................... { 
....................    struct 
....................    { 
....................       unsigned int16 count:10; 
....................       unsigned int8 bstall:1; 
....................       unsigned int8 dtsen:1; 
....................       unsigned int8 :2; 
....................       unsigned int8 data01:1; 
....................       unsigned int8 uown:1; 
....................    }; 
....................    struct 
....................    { 
....................       unsigned int16 :10;  //reserved bits 0 and 1 of word 1 
....................       unsigned int8 pid:4; 
....................    }; 
.................... } usb_bd_stat_t; 
.................... typedef unsigned int16 usb_bd_ptr_t; 
.................... #endif 
....................  
....................  
.................... /* 
....................    Options that USB_PING_PONG_MODE can be set to.  It must be set 
....................    to one of these choices. 
....................  
....................    If you use USB_PING_PONG_MODE_ON, you can also define USB_PING_PONG_EVEN_ONLY 
....................    where BDT is allocated for full ping-pong buffering but the peripheral 
....................    only uses the EVEN buffers. 
.................... */ 
.................... #define USB_PING_PONG_MODE_OFF         0     //no ping pong.  Not supported on EP chips. 
.................... #define USB_PING_PONG_MODE_E0_RX       1     //ping pong endpoint 0 RX (OUT) only.  Not supported on EP chips. 
.................... #define USB_PING_PONG_MODE_ON          2     //ping pong all endpoints 
.................... #define USB_PING_PONG_MODE_ON_BUT_E0   3     //ping pong on all endpoints but E0.  Not supported on EP chips. 
....................  
.................... /* 
....................    NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
....................  
....................    I would not mess with this as many things may break. 
....................  
....................    On PIC24EP/dsPIC33EP chips, ping pong is enabled but always using the 
....................    EVEN buffers.  You cannot truly disable ping-pong buffering on these 
....................    chips. 
.................... */ 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #if defined(__PIC24EP_USB__) 
....................       #define USB_PING_PONG_MODE USB_PING_PONG_MODE_ON 
....................       #define USB_PING_PONG_EVEN_ONLY 
....................    #else 
....................       #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
....................    #endif 
.................... #endif 
....................  
.................... #if ((USB_PING_PONG_MODE==USB_PING_PONG_MODE_E0_RX)||(USB_PING_PONG_MODE==USB_PING_PONG_MODE_ON)) 
....................    #define USB_EP0_RX_BUFFERS 2 
.................... #else 
....................    #define USB_EP0_RX_BUFFERS 1 
.................... #endif 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_ON) 
....................    #define USB_EP0_TX_BUFFERS 2 
.................... #else 
....................    #define USB_EP0_TX_BUFFERS 1 
.................... #endif 
....................  
.................... #if ((USB_PING_PONG_MODE==USB_PING_PONG_MODE_ON)||(USB_PING_PONG_MODE==USB_PING_PONG_MODE_ON_BUT_E0)) 
....................    #define USB_EPN_TXRX_BUFFERS 2 
.................... #else 
....................    #define USB_EPN_TXRX_BUFFERS 1 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    usb_bd_stat_t stat; 
....................    usb_bd_ptr_t ptr; 
.................... } usb_pd_buffer_t; 
....................  
.................... struct 
.................... { 
....................    usb_pd_buffer_t ep0out[USB_EP0_RX_BUFFERS];  //pic rx 
....................    usb_pd_buffer_t ep0in[USB_EP0_TX_BUFFERS];   //pic tx 
....................   #if (USB_LAST_DEFINED_ENDPOINT != 0) 
....................    usb_pd_buffer_t epn[USB_LAST_DEFINED_ENDPOINT][2][USB_EPN_TXRX_BUFFERS]; 
....................   #endif 
.................... } g_UsbBdt; 
.................... #ifndef PIC24_USB_BDT_LOC 
.................... #define PIC24_USB_BDT_LOC 0x1200 
.................... #endif 
.................... #locate g_UsbBdt=PIC24_USB_BDT_LOC 
....................  
.................... //dir 0 = rx(out), 1 = tx(in) 
.................... uint8_t * UsbEpBdXGetStPtr(uint8_t ep, int1 dir) 
*
00384:  MOV     W5,[W15++]
.................... { 
....................    uint8_t *ptr; 
....................  
....................    // only supports no ping pong or even only ping pong 
....................  
....................    if (ep == 0) 
00386:  MOV     4240,W0
00388:  CLR.B   1
0038A:  CP0.B   W0L
0038C:  BRA     NZ,3A6
....................    { 
....................       if (dir) 
0038E:  MOV     4240,W0
00390:  LSR     W0,#8,W0
00392:  CP0.B   W0L
00394:  BRA     Z,39E
....................          ptr = &g_UsbBdt.ep0in[0].stat; 
00396:  MOV     #1210,W4
00398:  MOV     W4,4242
0039A:  GOTO    3A2
....................       else 
....................          ptr = &g_UsbBdt.ep0out[0].stat; 
0039E:  MOV     #1200,W4
003A0:  MOV     W4,4242
....................    } 
003A2:  GOTO    3C4
....................    else 
....................    { 
....................       ptr = &g_UsbBdt.epn[ep-1][dir][0].stat; 
003A6:  MOV     4240,W4
003A8:  CLR.B   9
003AA:  SUB     W4,#1,W5
003AC:  SL      W5,#5,W0
003AE:  MOV     #20,W4
003B0:  ADD     W0,W4,W5
003B2:  PUSH    4240
003B4:  MOV     [--W15],W0
003B6:  LSR     W0,#8,W0
003B8:  CLR.B   1
003BA:  SL      W0,#4,W0
003BC:  ADD     W0,W5,W5
003BE:  MOV     #1200,W4
003C0:  ADD     W5,W4,W0
003C2:  MOV     W0,4242
....................    } 
....................  
....................    return(ptr); 
003C4:  PUSH    4242
003C6:  POP     0
003C8:  MOV     [--W15],W5
003CA:  RETURN  
.................... } 
....................  
.................... void UsbEpBdXGetSt(uint8_t ep, int1 dir, usb_bd_stat_t *pDst) 
*
006DC:  MOV     W5,[W15++]
.................... { 
....................    usb_bd_stat_t *pSrc; 
....................  
....................    pSrc = UsbEpBdXGetStPtr(ep, dir); 
006DE:  MOV     423A,W0
006E0:  PUSH    4240
006E2:  MOV.B   W0L,[W15-#2]
006E4:  POP     4240
006E6:  PUSH    423A
006E8:  MOV     [--W15],W0
006EA:  LSR     W0,#8,W0
006EC:  PUSH    4240
006EE:  MOV.B   W0L,[W15-#1]
006F0:  POP     4240
006F2:  CALL    384
006F6:  MOV     W0,423E
....................  
....................   //#if defined(__PIC24EP_USB__) 
....................   #if 0 
....................    memcpy(pDst, pSrc, sizeof(usb_bd_stat_t)); 
....................   #else 
....................    *pDst = *pSrc; 
006F8:  MOV     423C,W5
006FA:  MOV     423E,W0
006FC:  MOV     W0,W4
006FE:  MOV     #0,W3
00700:  MOV     [W4++],[W3++]
00702:  MOV     [W4++],[W3++]
00704:  MOV     #0,W4
00706:  MOV     [W4++],[W5++]
00708:  MOV     [W4++],[W5++]
....................   #endif 
0070A:  MOV     [--W15],W5
0070C:  RETURN  
.................... } 
....................  
.................... void UsbEpBdXSetSt(uint8_t ep, int1 dir, usb_bd_stat_t *pSrc) 
*
00416:  MOV     W5,[W15++]
.................... { 
....................    usb_bd_stat_t *pDst; 
....................  
....................    pDst = UsbEpBdXGetStPtr(ep, dir); 
00418:  MOV     4234,W0
0041A:  PUSH    4240
0041C:  MOV.B   W0L,[W15-#2]
0041E:  POP     4240
00420:  PUSH    4234
00422:  MOV     [--W15],W0
00424:  LSR     W0,#8,W0
00426:  PUSH    4240
00428:  MOV.B   W0L,[W15-#1]
0042A:  POP     4240
0042C:  CALL    384
00430:  MOV     W0,4238
....................  
....................   //#if defined(__PIC24EP_USB__) 
....................   #if 0 
....................    memcpy(pDst, pSrc, sizeof(usb_bd_stat_t)); 
....................   #else 
....................    *pDst = *pSrc; 
00432:  MOV     4238,W5
00434:  MOV     4236,W0
00436:  MOV     W0,W4
00438:  MOV     #0,W3
0043A:  MOV     [W4++],[W3++]
0043C:  MOV     [W4++],[W3++]
0043E:  MOV     #0,W4
00440:  MOV     [W4++],[W5++]
00442:  MOV     [W4++],[W5++]
....................   #endif 
00444:  MOV     [--W15],W5
00446:  RETURN  
.................... } 
....................  
.................... //dir 0 = rx(out), 1 = tx(in) 
.................... uint8_t * UsbEpBdXGetPtrPtr(uint8_t ep, int1 dir) 
.................... { 
....................    uint8_t *ptr; 
....................  
....................    ptr = UsbEpBdXGetStPtr(ep, dir); 
*
003CC:  MOV     422C,W0
003CE:  PUSH    4240
003D0:  MOV.B   W0L,[W15-#2]
003D2:  POP     4240
003D4:  PUSH    422C
003D6:  MOV     [--W15],W0
003D8:  LSR     W0,#8,W0
003DA:  PUSH    4240
003DC:  MOV.B   W0L,[W15-#1]
003DE:  POP     4240
003E0:  CALL    384
003E4:  MOV     W0,422E
....................  
....................    ptr += sizeof(usb_bd_stat_t); 
003E6:  MOV     422E,W0
003E8:  ADD     W0,#4,W0
003EA:  MOV     W0,422E
....................  
....................    return(ptr); 
003EC:  PUSH    422E
003EE:  POP     0
003F0:  RETURN  
.................... } 
....................  
.................... void UsbEpBdXGetPtr(uint8_t ep, int1 dir, usb_bd_ptr_t *pDst) 
.................... { 
....................    usb_bd_ptr_t *pSrc; 
....................  
....................    pSrc = UsbEpBdXGetPtrPtr(ep, dir); 
*
010EA:  MOV     4226,W0
010EC:  PUSH    422C
010EE:  MOV.B   W0L,[W15-#2]
010F0:  POP     422C
010F2:  PUSH    4226
010F4:  MOV     [--W15],W0
010F6:  LSR     W0,#8,W0
010F8:  PUSH    422C
010FA:  MOV.B   W0L,[W15-#1]
010FC:  POP     422C
010FE:  CALL    3CC
01102:  MOV     W0,422A
....................  
....................    memcpy(pDst, pSrc, sizeof(usb_bd_ptr_t)); 
01104:  MOV     4228,W1
01106:  MOV     422A,W2
01108:  REPEAT  #3
0110A:  MOV.B   [W2++],[W1++]
0110C:  RETURN  
.................... } 
....................  
.................... void UsbEpBdXSetPtr(uint8_t ep, int1 dir, usb_bd_ptr_t *pSrc) 
.................... { 
....................    usb_bd_ptr_t *pDst; 
....................  
....................    pDst = UsbEpBdXGetPtrPtr(ep, dir); 
*
003F2:  MOV     4224,W0
003F4:  PUSH    422C
003F6:  MOV.B   W0L,[W15-#2]
003F8:  POP     422C
003FA:  PUSH    4224
003FC:  MOV     [--W15],W0
003FE:  LSR     W0,#8,W0
00400:  PUSH    422C
00402:  MOV.B   W0L,[W15-#1]
00404:  POP     422C
00406:  CALL    3CC
0040A:  MOV     W0,4228
....................  
....................    memcpy(pDst, pSrc, sizeof(usb_bd_ptr_t)); 
0040C:  MOV     4228,W1
0040E:  MOV     4226,W2
00410:  REPEAT  #3
00412:  MOV.B   [W2++],[W1++]
00414:  RETURN  
.................... } 
....................  
.................... usb_bd_ptr_t EP_BDxADR_I(uint8_t ep) 
.................... { 
....................    usb_bd_ptr_t ret; 
....................  
....................    UsbEpBdXGetPtr(ep, 1, &ret); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... #if defined(__DO_DEBUG_USB) 
.................... usb_bd_stat_t EP_BDxST_I(uint8_t ep) 
.................... { 
....................    usb_bd_stat_t ret; 
....................  
....................    UsbEpBdXGetSt(ep, 1, &ret); 
....................  
....................    return(ret); 
.................... } 
.................... usb_bd_stat_t EP_BDxST_O(uint8_t ep) 
.................... { 
....................    usb_bd_stat_t ret; 
....................  
....................    UsbEpBdXGetSt(ep, 0, &ret); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... usb_bd_ptr_t EP_BDxADR_O(uint8_t ep) 
.................... { 
....................    usb_bd_ptr_t ret; 
....................  
....................    UsbEpBdXGetPtr(ep, 0, &ret); 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... union 
.................... { 
....................    struct 
....................    { 
....................       unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................       unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................  
....................       //these buffer definitions needed for CDC library 
....................      #if USB_EP1_RX_SIZE 
....................       unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................      #endif 
....................      #if USB_EP1_TX_SIZE 
....................       unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................      #endif 
....................      #if USB_EP2_RX_SIZE 
....................       unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................      #endif 
....................      #if USB_EP2_TX_SIZE 
....................       unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................      #endif 
....................    }; 
....................    unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
.................... } g_USBDataBuffer; 
.................... //#if defined(__DO_DEBUG_USB) 
.................... #if 0 
.................... #define USB_DATA_BUFFER_LOCATION 0x1400 
.................... #locate g_USBDataBuffer=USB_DATA_BUFFER_LOCATION 
.................... #warning why not do a locate and change some debugs to actually look at this locate, incase pointers got corrupted (USB_MAX_EP0_PACKET_LENGTH, rx, tx) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION &g_USBDataBuffer.general[0] 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer  g_USBDataBuffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer  g_USBDataBuffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBDataBuffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBDataBuffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBDataBuffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBDataBuffer.ep2_tx_buffer 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic24 memory locations 
.................... #word UOTGIR  =  getenv("SFR:U1OTGIR") 
.................... #word UOTGIE  =  getenv("SFR:U1OTGIE") 
.................... #word UOTGCON =  getenv("SFR:U1OTGCON") 
.................... #word UPWRC   =  getenv("SFR:U1PWRC") 
.................... #word UIR     =  getenv("SFR:U1IR") 
.................... #word UIE     =  getenv("SFR:U1IE") 
.................... #word UEIR    =  getenv("SFR:U1EIR") 
.................... #word UEIE    =  getenv("SFR:U1EIE") 
.................... #word USTAT   =  getenv("SFR:U1STAT") 
.................... #word UCON    =  getenv("SFR:U1CON") 
.................... #word UADDR   =  getenv("SFR:U1ADDR") 
.................... #word UBDTP1  =  getenv("SFR:U1BDTP1") 
.................... #if (getenv("SFR_VALID:U1BDTP2")) 
.................... #word UBDTP2  =  getenv("SFR:U1BDTP2") 
.................... #endif 
.................... #if (getenv("SFR_VALID:U1BDTP3")) 
.................... #word UBDTP3  =  getenv("SFR:U1BDTP3") 
.................... #endif 
.................... #word UFRML   =  getenv("SFR:U1FRML") 
.................... #word UFRMH   =  getenv("SFR:U1FRMH") 
.................... #word UCFG1   =  getenv("SFR:U1CNFG1") 
.................... #word UCFG2   =  getenv("SFR:U1CNFG2") 
.................... #define  UEP0_LOC getenv("SFR:U1EP0") 
....................  
.................... unsigned int16 UEP_SFR[16]; 
.................... #locate UEP_SFR=UEP0_LOC 
....................  
.................... #define UEP(x) UEP_SFR[x] 
....................  
.................... #define UIE_BIT_URST    0 
.................... #define UIE_BIT_UERR    1 
.................... #define UIE_BIT_SOF     2 
.................... #define UIE_BIT_TRN     3 
.................... #define UIE_BIT_IDLE    4 
.................... #define UIE_BIT_STALL   7 
....................  
.................... #BIT UIE_SOF = UIE.UIE_BIT_SOF 
.................... #BIT UIE_STALL = UIE.UIE_BIT_STALL 
.................... #BIT UIE_IDLE = UIE.UIE_BIT_IDLE 
.................... #BIT UIE_TRN = UIE.UIE_BIT_TRN 
.................... #BIT UIE_UERR = UIE.UIE_BIT_UERR 
.................... #BIT UIE_URST = UIE.UIE_BIT_URST 
....................  
.................... #define UOTGIE_BIT_ACTV 4 
....................  
.................... #BIT UOTGIE_ACTV=UOTGIE.UOTGIE_BIT_ACTV 
....................  
.................... #BIT UIR_SOF = UIR.UIE_BIT_SOF 
.................... #BIT UIR_STALL = UIR.UIE_BIT_STALL 
.................... #BIT UIR_IDLE = UIR.UIE_BIT_IDLE 
.................... #BIT UIR_TRN = UIR.UIE_BIT_TRN 
.................... #BIT UIR_UERR = UIR.UIE_BIT_UERR 
.................... #BIT UIR_URST = UIR.UIE_BIT_URST 
....................  
.................... #BIT UOTGIR_ACTV=UOTGIR.UOTGIE_BIT_ACTV 
....................  
.................... #define __USB_UIF_RESET    (1 << UIE_BIT_URST) 
.................... #define __USB_UIF_ERROR    (1 << UIE_BIT_UERR) 
.................... #define __USB_UIF_TOKEN    (1 << UIE_BIT_TRN) 
.................... #define __USB_UIF_IDLE     (1 << UIE_BIT_IDLE) 
.................... #define __USB_UIF_STALL    (1 << UIE_BIT_STALL) 
.................... #define __USB_UIF_SOF      (1 << UIE_BIT_SOF) 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #bit UOTGCON_DPPULUP = UOTGCON.7 
.................... #bit UOTGCON_DPMULUP = UOTGCON.6 
....................  
.................... #bit UCON_SE0=UCON.6 
.................... #bit UCON_PKTDIS=UCON.5 
.................... #bit UCON_USBEN=UCON.0 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_PPBRST=UCON.1 
....................  
.................... #bit UPWRC_USBPWR=UPWRC.0 
.................... #bit UPWRC_SUSPND=UPWRC.1 
.................... #define UCON_SUSPND UPWRC_SUSPND 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x04    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x08    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x0C    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x1C  //Supports both IN and OUT transactions 
....................  
.................... #define __UEP_EPHSK  0x01 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... #define USTAT_IN_E0        8 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UCFG1_UTEYE   0x80 
.................... #define __USB_UCFG1_UOEMON  0x40 
....................  
.................... /* wrong 
.................... #define __USB_UCFG2_PUVBUS  0x10 //microchip calls this USB_PULLUP_ENABLE 
.................... #define __USB_UCFG2_UTRDIS  0x01 //microchip calls this USB_EXTERNAL_TRANSCEIVER 
.................... #define __UCFG2_VAL_ENABLED__ __USB_UCFG2_PUVBUS 
.................... */ 
.................... #define __UCFG2_VAL_ENABLED__ 0 
....................  
.................... //#define __UCFG1_VAL_ENABLED__ USB_PING_PONG_MODE 
....................  
.................... #if defined(__PIC24EP_USB__) 
....................    //newer pic24EP/dspic33EP chips 
....................    #define __UCFG1_VAL_ENABLED__ 0 
.................... #else 
....................    //older pic24/dsPIC33 chips 
....................    #define __UCFG1_VAL_ENABLED__ USB_PING_PONG_MODE 
.................... #endif 
....................  
.................... #define __UCFG1_VAL_DISABLED__   0 
.................... #define __UCFG2_VAL_DISABLED__ 0 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) && defined(USB_INTERNAL_PULLUPS) 
....................  #error Can not use both internal and external pullups at the same time! 
.................... #endif 
....................  
.................... #if !defined(USB_EXTERNAL_PULLUPS) && !defined(USB_INTERNAL_PULLUPS) 
....................  #define USB_INTERNAL_PULLUPS 
.................... #endif 
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC24 peripheral only 
.................... void usb_handle_interrupt(void); 
.................... void usb_isr_rst(void); 
.................... void usb_isr_uerr(void); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(void); 
.................... void usb_isr_uidle(void); 
.................... void usb_isr_tok_dne(void); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
....................  
.................... //following functions standard part of CCS PIC USB driver, and used by usb.c 
.................... unsigned int16 usb_get_packet_buffer(unsigned int8 endpoint, unsigned int8 *ptr, unsigned int16 max); 
....................  
.................... static void usb_clear_trn(void); 
....................  
.................... static void usb_clear_isr_flag(unsigned int16 *sfr, unsigned int8 bit); 
.................... static void usb_clear_isr_reg(unsigned int16 *sfr); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    usb_bd_stat_t stat; 
....................    UsbEpBdXGetSt(en, 0, &stat); 
....................    //return((UEP(en) != ENDPT_DISABLED) && ((EP_BDxST_O(en) & __BDST_UOWN) == 0)); 
....................    return((UEP(en) != ENDPT_DISABLED) && !stat.uown); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
*
00EFE:  MOV     W5,[W15++]
.................... { 
....................    usb_bd_stat_t stat; 
....................    UsbEpBdXGetSt(en, 1, &stat); 
00F00:  MOV     4234,W0
00F02:  PUSH    423A
00F04:  MOV.B   W0L,[W15-#2]
00F06:  POP     423A
00F08:  MOV     423A,W0
00F0A:  SWAP    W0
00F0C:  MOV.B   #1,W0L
00F0E:  SWAP    W0
00F10:  MOV     W0,423A
00F12:  MOV     #4236,W4
00F14:  MOV     W4,423C
00F16:  CALL    6DC
....................    //return((UEP(en)!=ENDPT_DISABLED) && ((EP_BDxST_I(en) & __BDST_UOWN) == 0)); 
....................    return((UEP(en)!=ENDPT_DISABLED) && !stat.uown); 
00F1A:  MOV     4234,W0
00F1C:  CLR.B   1
00F1E:  SL      W0,#1,W0
00F20:  MOV     #4E0,W4
00F22:  ADD     W0,W4,W0
00F24:  MOV     [W0],W5
00F26:  CP0     W5
00F28:  BRA     Z,F30
00F2A:  MOV     4236,W4
00F2C:  BTSS    W4.7
00F2E:  BRA     F36
00F30:  CLR.B   W0
00F32:  GOTO    F38
00F36:  MOV.B   #1,W0L
00F38:  MOV     [--W15],W5
00F3A:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
....................    UIE = 0;   //disable USB interrupts 
....................    usb_clear_isr_reg(&UEIR); 
....................    usb_clear_isr_reg(&UIR); 
....................    UOTGIE = 0; 
....................    UPWRC_USBPWR = 1; 
....................    UCFG1 = __UCFG1_VAL_DISABLED__; 
....................    UCFG2 = __UCFG2_VAL_DISABLED__; 
....................    UCON_PPBRST = 1; 
....................  
....................    //set_tris_g(get_tris_g() | 0x0C); //set d+/d- pins to input //pin_g2 and pin_g3 
....................    usb_state=USB_STATE_DETACHED; 
....................    UADDR = 0; 
....................  
....................    memset(&UEP_SFR[0], 0x00, sizeof(UEP_SFR)); 
....................  
....................    memset(&g_UsbBdt, 0x00, sizeof(g_UsbBdt)); 
....................  
....................    UBDTP1 = &g_UsbBdt >> 8; 
....................    debug_usb(debug_putc, "\r\nDETACH p=%02X", UBDTP1); 
....................    
....................    #if (getenv("SFR_VALID:U1BDTP2")) 
....................    UBDTP2 = &g_UsbBdt >> 16; 
....................    #endif 
....................    #if (getenv("SFR_VALID:U1BDTP3")) 
....................    UBDTP3 = &g_UsbBdt >> 24; 
....................    debug_usb(debug_putc, "%02X%02X", UBDTP2, UBDTP3); 
....................    #endif 
....................  
....................   #if !defined(USB_PING_PONG_EVEN_ONLY) 
....................    UCON_PPBRST = 0; 
....................   #endif 
....................  
....................    debug_usb(debug_putc, " %LX ", &g_UsbBdt); 
....................  
....................  
....................    usb_token_reset();              //clear the chapter9 stack 
....................    UCON_PKTDIS=0; 
....................    //__usb_kbhit_status=0; 
....................  
....................    /* 
....................    UCON = 0;  //disable USB hardware 
....................    UIE = 0;   //disable USB interrupts 
....................    usb_state = USB_STATE_DETACHED; 
....................    */ 
....................    UOTGCON_DPPULUP = 0; 
....................    UOTGCON_DPMULUP = 0; 
....................   #if defined(USB_INTERNAL_PULLUPS) 
....................    #if USB_USE_FULL_SPEED 
....................     UOTGCON_DPPULUP = 1; 
....................    #else 
....................     UOTGCON_DPMULUP = 1; 
....................    #endif 
....................   #endif 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... static void usb_attach(void) 
.................... { 
....................    usb_token_reset(); 
....................  
....................    UCON = 0; 
....................   #if defined(USB_PING_PONG_EVEN_ONLY) 
....................    UCON_PPBRST = 1; 
....................   #endif 
....................    UIE = 0;                                // Mask all USB interrupts 
....................    UCFG1 = __UCFG1_VAL_ENABLED__; 
....................    UCFG2 = __UCFG2_VAL_ENABLED__; 
....................  
....................    while (!UCON_USBEN) {UCON_USBEN = 1;}  // Enable module & attach to bus 
....................  
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void) { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_enumerated()) 
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached()) { 
....................       if (UCON_USBEN==0) { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
....................          //delay_ms(50); 
....................       } 
....................    } 
....................    else { 
....................       if (UCON_USBEN==1)  { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) 
....................    { 
....................       usb_clear_isr_reg(&UIR); 
....................       UIE=0; 
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
....................       enable_interrupts(INTR_GLOBAL); 
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB interrupt 
....................       usb_state=USB_STATE_POWERED; 
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void) 
.................... { 
....................    usb_init_cs(); 
....................  
....................    do 
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
.................... // see pic24_usb.h for documentation 
.................... int1 usb_flush_in(unsigned int8 endpoint, unsigned int16 len, USB_DTS_BIT tgl) 
.................... { 
....................    usb_bd_stat_t newBD, oldBD; 
....................  
....................    memset(&newBD, 0x00, sizeof(newBD)); 
00F3C:  MOV     #422A,W1
00F3E:  MOV     #0,W2
00F40:  REPEAT  #3
00F42:  CLR.B   [W1++]
....................  
....................    /*if (display) 
....................    { 
....................       debug_usb(debug_putc, "\r\nPUT e%U t%U l%LU s%08LX a%08LX uc%02X ", endpoint, tgl, len, (unsigned int32)EP_BDxST_I(endpoint), (unsigned int32)EP_BDxADR_I(endpoint), UCON); 
....................    }*/ 
....................  
....................    if (usb_tbe(endpoint)) 
00F44:  MOV     4226,W0
00F46:  PUSH    4234
00F48:  MOV.B   W0L,[W15-#2]
00F4A:  POP     4234
00F4C:  CALL    EFE
00F50:  CP0.B   W0L
00F52:  BRA     Z,100E
....................    { 
....................       newBD.count = len; 
00F54:  PUSH    4228
00F56:  POP     422C
....................  
....................      #if defined(__DO_DEBUG_USB) 
....................       usb_bd_ptr_t bdPtr; 
....................       UsbEpBdXGetPtr(endpoint, 1, &bdPtr); 
....................       debug_usb_packet(debug_putc, "\r\nTX e%U ", endpoint); 
....................       debug_display_ram(len, bdPtr); 
....................      #endif 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       newBD.uown = TRUE; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE) 
00F58:  MOV     4226,W0
00F5A:  LSR     W0,#8,W0
00F5C:  CP.B    W0L,#2
00F5E:  BRA     NZ,FA2
....................       { 
....................          UsbEpBdXGetSt(endpoint, 1, &oldBD); 
00F60:  MOV     4226,W0
00F62:  PUSH    423A
00F64:  MOV.B   W0L,[W15-#2]
00F66:  POP     423A
00F68:  MOV     423A,W0
00F6A:  SWAP    W0
00F6C:  MOV.B   #1,W0L
00F6E:  SWAP    W0
00F70:  MOV     W0,423A
00F72:  MOV     #422E,W4
00F74:  MOV     W4,423C
00F76:  CALL    6DC
....................          tgl = oldBD.data01; 
00F7A:  MOV     422E,W4
00F7C:  CLR     W3
00F7E:  BTSC    W4.6
00F80:  INC     W3,W3
00F82:  PUSH    4226
00F84:  MOV.B   W3L,[W15-#1]
00F86:  POP     4226
....................          tgl = !tgl; 
00F88:  MOV     4226,W0
00F8A:  LSR     W0,#8,W0
00F8C:  CP0.B   W0L
00F8E:  BRA     Z,F96
00F90:  CLR.B   W0
00F92:  GOTO    F98
00F96:  MOV.B   #1,W0L
00F98:  PUSH    4226
00F9A:  MOV.B   W0L,[W15-#1]
00F9C:  POP     4226
....................          //if (display) {debug_usb(debug_putc, "dT "); } 
....................       } 
00F9E:  GOTO    FCE
....................       else if (tgl == USB_DTS_USERX) 
00FA2:  MOV     4226,W0
00FA4:  LSR     W0,#8,W0
00FA6:  CP.B    W0L,#4
00FA8:  BRA     NZ,FCE
....................       { 
....................          UsbEpBdXGetSt(endpoint, 0, &oldBD); 
00FAA:  MOV     4226,W0
00FAC:  PUSH    423A
00FAE:  MOV.B   W0L,[W15-#2]
00FB0:  POP     423A
00FB2:  MOV     423A,W0
00FB4:  CLR.B   1
00FB6:  MOV     W0,423A
00FB8:  MOV     #422E,W4
00FBA:  MOV     W4,423C
00FBC:  CALL    6DC
....................          tgl = oldBD.data01; 
00FC0:  MOV     422E,W4
00FC2:  CLR     W3
00FC4:  BTSC    W4.6
00FC6:  INC     W3,W3
00FC8:  PUSH    4226
00FCA:  MOV.B   W3L,[W15-#1]
00FCC:  POP     4226
....................          //if (display) {debug_usb(debug_putc, "dR%us%08lxe%u ", tgl, (unsigned int32)EP_BDxST_O(endpoint), endpoint); } 
....................       } 
....................  
....................       //if (display) {debug_usb(debug_putc, "d%U ", tgl); } 
....................  
....................       newBD.data01 = tgl; 
00FCE:  MOV     422A,W4
00FD0:  BCLR.B  8.6
00FD2:  PUSH    4226
00FD4:  MOV     [--W15],W3
00FD6:  LSR     W3,#8,W3
00FD8:  BTSC    W3.0
00FDA:  BSET.B  8.6
00FDC:  PUSH    422A
00FDE:  MOV.B   W4L,[W15-#2]
00FE0:  POP     422A
....................       newBD.dtsen = TRUE; 
00FE2:  MOV     422A,W0
00FE4:  BSET.B  0.3
00FE6:  MOV     W0,422A
....................       newBD.uown = TRUE; 
00FE8:  MOV     422A,W0
00FEA:  BSET.B  0.7
00FEC:  MOV     W0,422A
....................      #endif 
....................  
....................      #if __PIC24_NINC_BIT__ 
....................       newBD.ninc = __PIC24_NINC_BIT__; 
....................      #endif 
....................  
....................       UsbEpBdXSetSt(endpoint, 1, &newBD); 
00FEE:  MOV     4226,W0
00FF0:  PUSH    4234
00FF2:  MOV.B   W0L,[W15-#2]
00FF4:  POP     4234
00FF6:  MOV     4234,W0
00FF8:  SWAP    W0
00FFA:  MOV.B   #1,W0L
00FFC:  SWAP    W0
00FFE:  MOV     W0,4234
01000:  MOV     #422A,W4
01002:  MOV     W4,4236
01004:  CALL    416
....................  
....................       //if (display) {debug_usb(debug_putc, " %08LX %U %08LX ", (unsigned int32)newBD, endpoint, (unsigned int32)EP_BDxST_I(endpoint)); } 
....................  
....................       //debug_display_ram(16, (void*)UBDTP1 << 8); 
....................       //debug_display_ram(16, 0x1200); 
....................  
....................       return(1); 
01008:  MOV.B   #1,W0L
0100A:  MOV.B   W0L,0
0100C:  BRA     1010
....................    } 
....................     /*else 
....................     { 
....................          if (display) { 
....................          debug_usb(debug_putc,"\r\nPUT_ERR1 "); 
....................          debug_display_ram(16, (void*)UBDTP1 << 8); } 
....................     }*/ 
....................    return(0); 
0100E:  CLR.B   0
01010:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation. 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl) 
.................... { 
....................    usb_bd_ptr_t bdPtr; 
....................  
....................    if (usb_tbe(endpoint)) 
*
0110E:  MOV     421A,W0
01110:  PUSH    4234
01112:  MOV.B   W0L,[W15-#2]
01114:  POP     4234
01116:  CALL    EFE
0111A:  CP0.B   W0L
0111C:  BRA     Z,1168
....................    { 
....................       UsbEpBdXGetPtr(endpoint, 1, &bdPtr); 
0111E:  MOV     421A,W0
01120:  PUSH    4226
01122:  MOV.B   W0L,[W15-#2]
01124:  POP     4226
01126:  MOV     4226,W0
01128:  SWAP    W0
0112A:  MOV.B   #1,W0L
0112C:  SWAP    W0
0112E:  MOV     W0,4226
01130:  MOV     #4220,W4
01132:  MOV     W4,4228
01134:  CALL    10EA
....................       memcpy(bdPtr, ptr, len); 
01138:  MOV     4220,W1
0113A:  MOV     421C,W2
0113C:  MOV     421E,W0
0113E:  DEC     W0,W0
01140:  BRA     NC,1146
01142:  REPEAT  W0
01144:  MOV.B   [W2++],[W1++]
....................  
....................       return(usb_flush_in(endpoint, len, tgl)); 
01146:  MOV     421A,W0
01148:  PUSH    4226
0114A:  MOV.B   W0L,[W15-#2]
0114C:  POP     4226
0114E:  PUSH    421A
01150:  MOV     [--W15],W0
01152:  LSR     W0,#8,W0
01154:  PUSH    4226
01156:  MOV.B   W0L,[W15-#1]
01158:  POP     4226
0115A:  PUSH    421E
0115C:  POP     4228
0115E:  CALL    F3C
01162:  BRA     116A
....................    } 
01164:  GOTO    1168
....................    else 
....................    { 
....................       debug_usb(debug_putc,"\r\nPUT_ERR2 %U %02X ", endpoint, UEP(endpoint)); 
....................       debug_display_ram(16, (void*)UBDTP1 << 8); 
....................      //#if defined(__DO_DEBUG_USB) 
....................      #if 0 
....................       if (endpoint == 0) 
....................       { 
....................          for(len=0;len<250;len++) 
....................          { 
....................             delay_ms(1); 
....................             uart_task(); 
....................          } 
....................       } 
....................      #endif 
....................    } 
....................  
....................    return(0); 
01168:  CLR.B   0
0116A:  RETURN  
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB.C 
....................  
.................... // see pic24_usb.h for documentation 
.................... void usb_flush_out(unsigned int8 endpoint, USB_DTS_BIT tgl) 
.................... { 
....................    usb_bd_stat_t newBD, oldBD; 
....................  
....................    memset(&newBD, 0x00, sizeof(newBD)); 
*
00E2E:  MOV     #421A,W1
00E30:  MOV     #0,W2
00E32:  REPEAT  #3
00E34:  CLR.B   [W1++]
....................  
....................   #if __PIC24_NINC_BIT__ 
....................    newBD.ninc = __PIC24_NINC_BIT__; 
....................   #endif 
....................  
....................      #if USB_IGNORE_RX_DTS 
....................       if (tgl == USB_DTS_STALL) 
....................       { 
....................          debug_usb(debug_putc, '*'); 
....................  
....................          newBD.uown = TRUE; 
....................          newBD.bstall = TRUE; 
....................  
....................          UsbEpBdXSetSt(endpoint, 1, &newBD); 
....................          UsbEpBdXSetSt(endpoint, 0, &newBD); 
....................          return; 
....................       } 
....................       else 
....................       { 
....................          newBD.uown = TRUE; 
....................       } 
....................      #else 
....................       //oldBD = g_UsbBdt.ep[endpoint].out; 
....................       if (tgl == USB_DTS_TOGGLE) 
00E36:  MOV     4218,W0
00E38:  LSR     W0,#8,W0
00E3A:  CP.B    W0L,#2
00E3C:  BRA     NZ,E78
....................       { 
....................          UsbEpBdXGetSt(endpoint, 0, &oldBD); 
00E3E:  MOV     4218,W0
00E40:  PUSH    423A
00E42:  MOV.B   W0L,[W15-#2]
00E44:  POP     423A
00E46:  MOV     423A,W0
00E48:  CLR.B   1
00E4A:  MOV     W0,423A
00E4C:  MOV     #421E,W4
00E4E:  MOV     W4,423C
00E50:  CALL    6DC
....................          tgl = oldBD.data01; 
00E54:  MOV     421E,W4
00E56:  CLR     W3
00E58:  BTSC    W4.6
00E5A:  INC     W3,W3
00E5C:  PUSH    4218
00E5E:  MOV.B   W3L,[W15-#1]
00E60:  POP     4218
....................          tgl = !tgl; 
00E62:  MOV     4218,W0
00E64:  LSR     W0,#8,W0
00E66:  CP0.B   W0L
00E68:  BRA     Z,E70
00E6A:  CLR.B   W0
00E6C:  GOTO    E72
00E70:  MOV.B   #1,W0L
00E72:  PUSH    4218
00E74:  MOV.B   W0L,[W15-#1]
00E76:  POP     4218
....................       } 
....................       if (tgl == USB_DTS_STALL) 
00E78:  MOV     4218,W0
00E7A:  LSR     W0,#8,W0
00E7C:  CP.B    W0L,#3
00E7E:  BRA     NZ,EAA
....................       { 
....................          newBD.uown = TRUE; 
00E80:  MOV     421A,W0
00E82:  BSET.B  0.7
00E84:  MOV     W0,421A
....................          newBD.bstall = TRUE; 
00E86:  MOV     421A,W0
00E88:  BSET.B  0.2
00E8A:  MOV     W0,421A
....................  
....................          UsbEpBdXSetSt(endpoint, 1, &newBD); 
00E8C:  MOV     4218,W0
00E8E:  PUSH    4234
00E90:  MOV.B   W0L,[W15-#2]
00E92:  POP     4234
00E94:  MOV     4234,W0
00E96:  SWAP    W0
00E98:  MOV.B   #1,W0L
00E9A:  SWAP    W0
00E9C:  MOV     W0,4234
00E9E:  MOV     #421A,W4
00EA0:  MOV     W4,4236
00EA2:  CALL    416
....................       } 
00EA6:  GOTO    EDA
....................       else if (tgl == USB_DTS_DATA1) 
00EAA:  MOV     4218,W0
00EAC:  LSR     W0,#8,W0
00EAE:  CP.B    W0L,#1
00EB0:  BRA     NZ,EC8
....................       { 
....................          newBD.uown = TRUE; 
00EB2:  MOV     421A,W0
00EB4:  BSET.B  0.7
00EB6:  MOV     W0,421A
....................          newBD.data01 = TRUE; 
00EB8:  MOV     421A,W0
00EBA:  BSET.B  0.6
00EBC:  MOV     W0,421A
....................          newBD.dtsen = TRUE; 
00EBE:  MOV     421A,W0
00EC0:  BSET.B  0.3
00EC2:  MOV     W0,421A
....................       } 
00EC4:  GOTO    EDA
....................       else //if (tgl == USB_DTS_DATA0) 
....................       { 
....................          newBD.uown = TRUE; 
00EC8:  MOV     421A,W0
00ECA:  BSET.B  0.7
00ECC:  MOV     W0,421A
....................          newBD.data01 = FALSE; 
00ECE:  MOV     421A,W0
00ED0:  BCLR.B  0.6
00ED2:  MOV     W0,421A
....................          newBD.dtsen = TRUE; 
00ED4:  MOV     421A,W0
00ED6:  BSET.B  0.3
00ED8:  MOV     W0,421A
....................       } 
....................      #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    newBD.count = usb_ep_rx_size[endpoint]; 
00EDA:  MOV     4218,W0
00EDC:  CLR.B   1
00EDE:  SL      W0,#1,W0
00EE0:  CALL    262
00EE4:  MOV     W0,421C
....................  
....................    UsbEpBdXSetSt(endpoint, 0, &newBD); 
00EE6:  MOV     4218,W0
00EE8:  PUSH    4234
00EEA:  MOV.B   W0L,[W15-#2]
00EEC:  POP     4234
00EEE:  MOV     4234,W0
00EF0:  CLR.B   1
00EF2:  MOV     W0,4234
00EF4:  MOV     #421A,W4
00EF6:  MOV     W4,4236
00EF8:  CALL    416
00EFC:  RETURN  
.................... } 
....................  
.................... // see pic24_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint) 
.................... { 
....................    usb_bd_stat_t stat; 
....................    UsbEpBdXGetSt(endpoint, 0, &stat); 
*
01050:  MOV     4218,W0
01052:  PUSH    423A
01054:  MOV.B   W0L,[W15-#2]
01056:  POP     423A
01058:  MOV     423A,W0
0105A:  CLR.B   1
0105C:  MOV     W0,423A
0105E:  MOV     #421A,W4
01060:  MOV     W4,423C
01062:  CALL    6DC
....................    return(stat.count); 
01066:  PUSH    421C
01068:  POP     0
0106A:  RETURN  
....................    //return(EP_BDxST_O(endpoint) & 0x03FF); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet_buffer(unsigned int8 endpoint, unsigned int8 *ptr, unsigned int16 max) 
.................... { 
....................    unsigned int16 i; 
....................    usb_bd_ptr_t bdPtr; 
....................  
....................    i = usb_rx_packet_size(endpoint); 
....................  
....................    //printf("\r\nUSB GET PACKET ST:%LX %U I=%LX MAX=%LX %X%X ", EP_BDxST_O(endpoint), endpoint, i, max, al[0], al[1]); 
....................  
....................    if (i<max) {max=i;} 
....................  
....................    if (max) 
....................    { 
....................       UsbEpBdXGetPtr(endpoint, 0, &bdPtr); 
....................       memcpy(ptr, bdPtr, max); 
....................    } 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max=usb_get_packet_buffer(endpoint,ptr,max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h 
.................... void usb_stall_ep(unsigned int8 endpoint) 
*
00BF8:  MOV     W5,[W15++]
.................... { 
....................    usb_bd_stat_t newBD; 
....................    int1 direction; 
....................  
....................    memset(&newBD, 0x00, sizeof(newBD)); 
00BFA:  MOV     #4218,W1
00BFC:  MOV     #0,W2
00BFE:  REPEAT  #3
00C00:  CLR.B   [W1++]
....................  
....................    newBD.uown = TRUE; 
00C02:  MOV     4218,W0
00C04:  BSET.B  0.7
00C06:  MOV     W0,4218
....................    newBD.bstall = TRUE; 
00C08:  MOV     4218,W0
00C0A:  BSET.B  0.2
00C0C:  MOV     W0,4218
....................  
....................   #if __PIC24_NINC_BIT__ 
....................    newBD.ninc = __PIC24_NINC_BIT__; 
....................   #endif 
....................  
....................    direction = bit_test(endpoint,7); 
00C0E:  PUSH    4216
00C10:  MOV     [--W15],W4
00C12:  LSR     W4,#8,W4
00C14:  BCLR.B  8.0
00C16:  MOV     4216,W3
00C18:  BTSC    W3.7
00C1A:  BSET.B  8.0
00C1C:  PUSH    4216
00C1E:  MOV.B   W4L,[W15-#1]
00C20:  POP     4216
....................    endpoint &= 0x7F; 
00C22:  MOV     4216,W0
00C24:  CLR.B   1
00C26:  BCLR    W0.7
00C28:  PUSH    4216
00C2A:  MOV.B   W0L,[W15-#2]
00C2C:  POP     4216
....................  
....................    UsbEpBdXSetSt(endpoint, direction, &newBD); 
00C2E:  MOV     4216,W4
00C30:  CLR     W0
00C32:  BTSC    W4.8
00C34:  INC     W0,W0
00C36:  MOV.B   W0L,W5L
00C38:  MOV     W0,[W15++]
00C3A:  MOV     4216,W0
00C3C:  PUSH    4234
00C3E:  MOV.B   W0L,[W15-#2]
00C40:  POP     4234
00C42:  MOV     [--W15],W0
00C44:  PUSH    4234
00C46:  MOV.B   W5L,[W15-#1]
00C48:  POP     4234
00C4A:  MOV     #4218,W4
00C4C:  MOV     W4,4236
00C4E:  CALL    416
00C52:  MOV     [--W15],W5
00C54:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint) 
*
00B72:  MOV     W5,[W15++]
.................... { 
....................    usb_bd_stat_t newBD; 
....................    int1 direction; 
....................  
....................    direction = bit_test(endpoint,7); 
00B74:  PUSH    4216
00B76:  MOV     [--W15],W4
00B78:  LSR     W4,#8,W4
00B7A:  BCLR.B  8.0
00B7C:  MOV     4216,W3
00B7E:  BTSC    W3.7
00B80:  BSET.B  8.0
00B82:  PUSH    4216
00B84:  MOV.B   W4L,[W15-#1]
00B86:  POP     4216
....................    endpoint &= 0x7F; 
00B88:  MOV     4216,W0
00B8A:  CLR.B   1
00B8C:  BCLR    W0.7
00B8E:  PUSH    4216
00B90:  MOV.B   W0L,[W15-#2]
00B92:  POP     4216
....................  
....................    memset(&newBD, 0x00, sizeof(newBD)); 
00B94:  MOV     #4218,W1
00B96:  MOV     #0,W2
00B98:  REPEAT  #3
00B9A:  CLR.B   [W1++]
....................  
....................    if (direction) 
00B9C:  MOV     4216,W4
00B9E:  BTSS    W4.8
00BA0:  BRA     BCC
....................    { 
....................       newBD.uown = TRUE; 
00BA2:  MOV     4218,W0
00BA4:  BSET.B  0.7
00BA6:  MOV     W0,4218
....................      #if !USB_IGNORE_RX_DTS 
....................       newBD.dtsen = TRUE; 
00BA8:  MOV     4218,W0
00BAA:  BSET.B  0.3
00BAC:  MOV     W0,4218
....................      #endif 
....................  
....................      #if __PIC24_NINC_BIT__ 
....................       newBD.ninc = __PIC24_NINC_BIT__; 
....................      #endif 
....................  
....................       UsbEpBdXSetSt(endpoint, 1, &newBD); 
00BAE:  MOV     4216,W0
00BB0:  PUSH    4234
00BB2:  MOV.B   W0L,[W15-#2]
00BB4:  POP     4234
00BB6:  MOV     4234,W0
00BB8:  SWAP    W0
00BBA:  MOV.B   #1,W0L
00BBC:  SWAP    W0
00BBE:  MOV     W0,4234
00BC0:  MOV     #4218,W4
00BC2:  MOV     W4,4236
00BC4:  CALL    416
....................    } 
00BC8:  GOTO    BE2
....................    else 
....................    { 
....................       UsbEpBdXSetSt(endpoint, 0, &newBD); 
00BCC:  MOV     4216,W0
00BCE:  PUSH    4234
00BD0:  MOV.B   W0L,[W15-#2]
00BD2:  POP     4234
00BD4:  MOV     4234,W0
00BD6:  CLR.B   1
00BD8:  MOV     W0,4234
00BDA:  MOV     #4218,W4
00BDC:  MOV     W4,4236
00BDE:  CALL    416
....................    } 
....................  
....................   #if defined(__STALL_ON_UEP_ERRATA__) 
....................    bit_clear(UEP(endpoint), 1); 
00BE2:  MOV     4216,W0
00BE4:  CLR.B   1
00BE6:  SL      W0,#1,W0
00BE8:  MOV     #4E0,W4
00BEA:  ADD     W0,W4,W0
00BEC:  MOV     W0,W5
00BEE:  MOV.B   [W5],W4L
00BF0:  AND.B   #FD,W4L
00BF2:  MOV.B   W4L,[W5+#0]
....................   #endif 
00BF4:  MOV     [--W15],W5
00BF6:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint) 
*
00C56:  MOV     W5,[W15++]
.................... { 
....................    int1 direction; 
....................    usb_bd_stat_t bd; 
....................  
....................    direction = bit_test(endpoint,7); 
00C58:  PUSH    4216
00C5A:  MOV     [--W15],W4
00C5C:  LSR     W4,#8,W4
00C5E:  BCLR.B  8.0
00C60:  MOV     4216,W3
00C62:  BTSC    W3.7
00C64:  BSET.B  8.0
00C66:  PUSH    4216
00C68:  MOV.B   W4L,[W15-#1]
00C6A:  POP     4216
....................    endpoint &= 0x7F; 
00C6C:  MOV     4216,W0
00C6E:  CLR.B   1
00C70:  BCLR    W0.7
00C72:  PUSH    4216
00C74:  MOV.B   W0L,[W15-#2]
00C76:  POP     4216
....................  
....................    UsbEpBdXGetSt(endpoint, direction, &bd); 
00C78:  MOV     4216,W4
00C7A:  CLR     W0
00C7C:  BTSC    W4.8
00C7E:  INC     W0,W0
00C80:  MOV.B   W0L,W5L
00C82:  MOV     W0,[W15++]
00C84:  MOV     4216,W0
00C86:  PUSH    423A
00C88:  MOV.B   W0L,[W15-#2]
00C8A:  POP     423A
00C8C:  MOV     [--W15],W0
00C8E:  PUSH    423A
00C90:  MOV.B   W5L,[W15-#1]
00C92:  POP     423A
00C94:  MOV     #4218,W4
00C96:  MOV     W4,423C
00C98:  CALL    6DC
....................  
....................    return(bd.uown && bd.bstall); 
00C9C:  MOV     4218,W4
00C9E:  BTSS    W4.7
00CA0:  BRA     CA8
00CA2:  MOV     4218,W4
00CA4:  BTSC    W4.2
00CA6:  BRA     CAE
00CA8:  CLR.B   W0
00CAA:  GOTO    CB0
00CAE:  MOV.B   #1,W0L
00CB0:  MOV     [--W15],W5
00CB2:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address) 
.................... { 
....................    UADDR = address; 
*
010BC:  MOV     4218,W0
010BE:  MOV.B   W0L,4CC
010C0:  CLR.B   4CD
....................  
....................    if (address) 
010C2:  MOV     4218,W0
010C4:  CLR.B   1
010C6:  CP0.B   W0L
010C8:  BRA     Z,10D2
....................       usb_state = USB_STATE_ADDRESS; 
010CA:  MOV.B   #4,W0L
010CC:  MOV.B   W0L,100B
010CE:  GOTO    10D6
....................    else 
....................       usb_state = USB_STATE_POWERED; 
010D2:  MOV.B   #2,W0L
010D4:  MOV.B   W0L,100B
010D6:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config) 
*
0086C:  MOV     W5,[W15++]
.................... { 
....................    unsigned int8 en; 
....................    usb_bd_ptr_t addy; 
....................    unsigned int16 new_uep; 
....................    unsigned int16 len; 
....................    usb_bd_stat_t newBD; 
....................  
....................    if (config == 0) 
0086E:  MOV     4216,W0
00870:  CLR.B   1
00872:  CP0.B   W0L
00874:  BRA     NZ,882
....................    {  //if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
00876:  MOV.B   #4,W0L
00878:  MOV.B   W0L,100B
....................       usb_disable_endpoints(); 
0087A:  CALL    64A
....................    } 
0087E:  GOTO    9F4
....................    else 
....................    { 
....................       usb_state = USB_STATE_CONFIGURED; //else set configed state 
00882:  MOV.B   #5,W0L
00884:  MOV.B   W0L,100B
....................       addy = USB_DATA_BUFFER_LOCATION + (2*USB_MAX_EP0_PACKET_LENGTH); //skip ep0 
00886:  MOV     #108C,W4
00888:  MOV     W4,4218
0088A:  MOV     #0,W4
0088C:  MOV     W4,421A
....................       for (en=1; en<16; en++) 
0088E:  MOV     4216,W0
00890:  SWAP    W0
00892:  MOV.B   #1,W0L
00894:  SWAP    W0
00896:  MOV     W0,4216
00898:  MOV     4216,W0
0089A:  LSR     W0,#8,W0
0089C:  CP.B    W0L,#10
0089E:  BRA     C,9F4
....................       { 
....................          usb_disable_endpoint(en); 
008A0:  PUSH    4216
008A2:  MOV     [--W15],W0
008A4:  LSR     W0,#8,W0
008A6:  PUSH    4226
008A8:  MOV.B   W0L,[W15-#2]
008AA:  POP     4226
008AC:  CALL    5EC
....................          new_uep = 0; 
008B0:  MOV     #0,W4
008B2:  MOV     W4,421C
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED) 
008B4:  PUSH    4216
008B6:  MOV     [--W15],W0
008B8:  LSR     W0,#8,W0
008BA:  CLR.B   1
008BC:  CALL    21C
008C0:  MOV     #FF,W4
008C2:  CP.B    W4L,W0L
008C4:  BRA     Z,934
....................          { 
....................             memset(&newBD, 0x00, sizeof(newBD)); 
008C6:  MOV     #4220,W1
008C8:  MOV     #0,W2
008CA:  REPEAT  #3
008CC:  CLR.B   [W1++]
....................  
....................             new_uep = ENDPT_OUT_ONLY; 
008CE:  MOV     #8,W4
008D0:  MOV     W4,421C
....................  
....................             len = usb_ep_rx_size[en]; 
008D2:  PUSH    4216
008D4:  MOV     [--W15],W0
008D6:  LSR     W0,#8,W0
008D8:  CLR.B   1
008DA:  SL      W0,#1,W0
008DC:  CALL    262
008E0:  MOV     W0,421E
....................  
....................             UsbEpBdXSetPtr(en, 0, &addy); 
008E2:  PUSH    4216
008E4:  MOV     [--W15],W0
008E6:  LSR     W0,#8,W0
008E8:  PUSH    4224
008EA:  MOV.B   W0L,[W15-#2]
008EC:  POP     4224
008EE:  MOV     4224,W0
008F0:  CLR.B   1
008F2:  MOV     W0,4224
008F4:  MOV     #4218,W4
008F6:  MOV     W4,4226
008F8:  CALL    3F2
....................  
....................             addy += len; 
008FC:  MOV     4218,W0
008FE:  MOV     421E,W4
00900:  ADD     W0,W4,W0
00902:  MOV     W0,4218
00904:  MOV     421A,W3
00906:  ADDC    W3,#0,W0
00908:  MOV     W0,421A
....................  
....................             newBD.uown = TRUE; 
0090A:  MOV     4220,W0
0090C:  BSET.B  0.7
0090E:  MOV     W0,4220
....................             #if !USB_IGNORE_RX_DTS 
....................                newBD.dtsen = TRUE; 
00910:  MOV     4220,W0
00912:  BSET.B  0.3
00914:  MOV     W0,4220
....................             #endif 
....................  
....................  
....................            #if __PIC24_NINC_BIT__ 
....................             newBD.ninc = __PIC24_NINC_BIT__; 
....................            #endif 
....................  
....................             newBD.count = len; 
00916:  PUSH    421E
00918:  POP     4222
....................  
....................             UsbEpBdXSetSt(en, 0, &newBD); 
0091A:  PUSH    4216
0091C:  MOV     [--W15],W0
0091E:  LSR     W0,#8,W0
00920:  PUSH    4234
00922:  MOV.B   W0L,[W15-#2]
00924:  POP     4234
00926:  MOV     4234,W0
00928:  CLR.B   1
0092A:  MOV     W0,4234
0092C:  MOV     #4220,W4
0092E:  MOV     W4,4236
00930:  CALL    416
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED) 
00934:  PUSH    4216
00936:  MOV     [--W15],W0
00938:  LSR     W0,#8,W0
0093A:  CLR.B   1
0093C:  CALL    200
00940:  MOV     #FF,W4
00942:  CP.B    W4L,W0L
00944:  BRA     Z,9B2
....................          { 
....................             memset(&newBD, 0x00, sizeof(newBD)); 
00946:  MOV     #4220,W1
00948:  MOV     #0,W2
0094A:  REPEAT  #3
0094C:  CLR.B   [W1++]
....................  
....................            #if __PIC24_NINC_BIT__ 
....................             newBD.ninc = __PIC24_NINC_BIT__; 
....................            #endif 
....................  
....................             new_uep |= ENDPT_IN_ONLY; 
0094E:  MOV     421C,W0
00950:  BSET    W0.2
00952:  MOV     W0,421C
....................  
....................             UsbEpBdXSetPtr(en, 1, &addy); 
00954:  PUSH    4216
00956:  MOV     [--W15],W0
00958:  LSR     W0,#8,W0
0095A:  PUSH    4224
0095C:  MOV.B   W0L,[W15-#2]
0095E:  POP     4224
00960:  MOV     4224,W0
00962:  SWAP    W0
00964:  MOV.B   #1,W0L
00966:  SWAP    W0
00968:  MOV     W0,4224
0096A:  MOV     #4218,W4
0096C:  MOV     W4,4226
0096E:  CALL    3F2
....................             addy += usb_ep_tx_size[en]; 
00972:  PUSH    4216
00974:  MOV     [--W15],W0
00976:  LSR     W0,#8,W0
00978:  CLR.B   1
0097A:  SL      W0,#1,W0
0097C:  CALL    238
00980:  MOV     4218,W4
00982:  ADD     W0,W4,W0
00984:  MOV     W0,4218
00986:  MOV     421A,W3
00988:  MOV     #0,W2
0098A:  ADDC    W2,W3,W0
0098C:  MOV     W0,421A
....................  
....................             newBD.data01 = TRUE; 
0098E:  MOV     4220,W0
00990:  BSET.B  0.6
00992:  MOV     W0,4220
....................  
....................             UsbEpBdXSetSt(en, 1, &newBD); 
00994:  PUSH    4216
00996:  MOV     [--W15],W0
00998:  LSR     W0,#8,W0
0099A:  PUSH    4234
0099C:  MOV.B   W0L,[W15-#2]
0099E:  POP     4234
009A0:  MOV     4234,W0
009A2:  SWAP    W0
009A4:  MOV.B   #1,W0L
009A6:  SWAP    W0
009A8:  MOV     W0,4234
009AA:  MOV     #4220,W4
009AC:  MOV     W4,4236
009AE:  CALL    416
....................          } 
....................  
....................          if (new_uep == (ENDPT_IN_ONLY | ENDPT_OUT_ONLY)) 
009B2:  MOV     421C,W0
009B4:  CP      W0,#C
009B6:  BRA     NZ,9BC
....................             new_uep = ENDPT_NON_CONTROL; 
009B8:  MOV     #1C,W4
009BA:  MOV     W4,421C
....................  
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) 
009BC:  PUSH    4216
009BE:  MOV     [--W15],W0
009C0:  LSR     W0,#8,W0
009C2:  CLR.B   1
009C4:  CALL    200
009C8:  CP.B    W0L,#1
009CA:  BRA     Z,9D2
....................             new_uep |= __UEP_EPHSK; 
009CC:  MOV     421C,W0
009CE:  BSET    W0.0
009D0:  MOV     W0,421C
....................  
....................          UEP(en) = new_uep; 
009D2:  PUSH    4216
009D4:  MOV     [--W15],W0
009D6:  LSR     W0,#8,W0
009D8:  CLR.B   1
009DA:  SL      W0,#1,W0
009DC:  MOV     #4E0,W4
009DE:  ADD     W0,W4,W5
009E0:  MOV     421C,W4
009E2:  MOV     W4,[W5+#0]
009E4:  MOV     4216,W0
009E6:  LSR     W0,#8,W0
009E8:  INC.B   W0L,W0L
009EA:  PUSH    4216
009EC:  MOV.B   W0L,[W15-#1]
009EE:  POP     4216
009F0:  GOTO    898
....................       } 
....................    } 
009F4:  MOV     [--W15],W5
009F6:  RETURN  
.................... } 
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    usb_clear_isr_flag(&UIR, UIE_BIT_TRN); 
*
00674:  MOV     4218,W0
00676:  MOV.B   #3,W0L
00678:  MOV     W0,4218
0067A:  MOV     #4C0,W4
0067C:  MOV     W4,4216
0067E:  CALL    350
....................    delay_cycles(6); 
00682:  REPEAT  #4
00684:  NOP     
00686:  RETURN  
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt method), 
.................... /*       then you must call this function rapidly.  If there is more than 10ms 
.................... /*       latency the PC may think the USB device is stalled and disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this fuction. 
.................... /*       Also, goto usb_init() and remove the code that enables the USB interrupt. 
.................... /********************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) 
.................... #if defined(USB_AUX_SERIAL_BOOTLOADER) && defined(_bootloader) 
.................... #int_aux 
.................... #else 
.................... #int_usb 
.................... #endif 
.................... #endif 
.................... void usb_isr(void) 
*
013D6:  PUSH    42
013D8:  PUSH    36
013DA:  PUSH    54
013DC:  MOV     W0,[W15++]
013DE:  MOV     #2,W0
013E0:  REPEAT  #C
013E2:  MOV     [W0++],[W15++]
013E4:  MOV     420C,W0
013E6:  MOV.B   #0,W0L
013E8:  MOV     W0,420C
.................... { 
....................    unsigned int8 TRNAttempts = 0; 
....................  
....................   //#if !defined(USB_ISR_POLLING) 
....................   // debug_putc('.'); 
....................   //#endif 
....................  
....................    if (usb_state==USB_STATE_DETACHED) return;   //should never happen, though 
013EA:  CP0.B   100B
013EC:  BRA     NZ,13F0
013EE:  BRA     146C
....................  
....................   #if defined(USB_ISR_POLLING) 
....................    if (((UIR&UIE)!= 0) || ((UOTGIR&UOTGIE)!=0)) 
....................   #else 
....................    if (UIR || UOTGIR) 
013F0:  CP0     4C0
013F2:  BRA     NZ,13F8
013F4:  CP0     488
013F6:  BRA     Z,146C
....................   #endif 
....................    { 
....................      #if defined(USB_ISR_POLLING) 
....................       //debug_putc('.'); 
....................       //#if 0 
....................       //printf(debug_putc, "%02x%02x ", UIR&UIE, UOTGIR&UOTGIE); 
....................       //#endif 
....................      #endif 
....................  
....................       //debug_usb(debug_putc,"\r\n\n[%X%X%U] ",(int8)UIR, (int8)UOTGIR, UCON_SUSPND); 
....................       if (UOTGIR_ACTV && UOTGIE_ACTV) {usb_isr_activity();}  //activity detected.  (only enable after sleep) 
013F8:  BTSS.B  488.4
013FA:  BRA     1404
013FC:  BTSS.B  48A.4
013FE:  BRA     1404
01400:  CALL    362
....................  
....................       if (UCON_SUSPND) return; 
01404:  BTSS.B  490.1
01406:  BRA     140A
01408:  BRA     146C
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0140A:  BTSS.B  4C0.7
0140C:  BRA     1416
0140E:  BTSS.B  4C2.7
01410:  BRA     1416
01412:  CALL    4D2
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
01416:  BTSS.B  4C0.1
01418:  BRA     1422
0141A:  BTSS.B  4C2.1
0141C:  BRA     1422
0141E:  CALL    4FA
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
01422:  BTSS.B  4C0.0
01424:  BRA     142E
01426:  BTSS.B  4C2.0
01428:  BRA     142E
0142A:  CALL    688
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
0142E:  BTSS.B  4C0.4
01430:  BRA     143A
01432:  BTSS.B  4C2.4
01434:  BRA     143A
01436:  CALL    6C6
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
0143A:  BTSS.B  4C0.2
0143C:  BRA     1446
0143E:  BTSS.B  4C2.2
01440:  BRA     1446
01442:  CALL    6CC
....................       //if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
....................  
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN) { 
01446:  BTSS.B  4C0.3
01448:  BRA     1456
0144A:  BTSS.B  4C2.3
0144C:  BRA     1456
....................             usb_isr_tok_dne(); 
0144E:  CALL    11D6
....................             //UIR_TRN=0;    // clear the token done interrupt., 0x190.3 
....................          }    //a token has been detected (majority of isrs) 
01452:  GOTO    145A
....................          else 
....................             break; 
01456:  GOTO    146C
....................       } 
....................       while (TRNAttempts++ < 4); 
0145A:  MOV     420C,W0
0145C:  MOV     W0,[W15++]
0145E:  INC.B   W0L,W0L
01460:  PUSH    420C
01462:  MOV.B   W0L,[W15-#2]
01464:  POP     420C
01466:  MOV     [--W15],W0
01468:  CP.B    W0L,#4
0146A:  BRA     NC,1446
....................      #if defined(USB_CDC_ISR) 
....................       //has to be done here, can't be done until TRN is empty. 
....................       if (usb_cdc_kbhit()) 
....................       { 
....................          USB_CDC_ISR(); 
....................       } 
....................      #endif 
....................    } 
....................     
....................   #if defined(USB_AUX_SERIAL_BOOTLOADER) && defined(_bootloader) 
....................    clear_interrupt(INT_USB); 
....................   #endif 
0146C:  BCLR.B  80A.6
0146E:  MOV     #1A,W0
01470:  REPEAT  #C
01472:  MOV     [--W15],[W0--]
01474:  MOV     [--W15],W0
01476:  POP     54
01478:  POP     36
0147A:  POP     42
0147C:  RETFIE  
.................... } 
....................  
.................... //SOF interrupt not handled.  user must add this depending on application 
.................... void usb_isr_sof(void) 
.................... { 
....................    debug_usb(debug_putc,"\r\nSOF"); 
....................    usb_clear_isr_flag(&UIR, UIE_BIT_SOF); 
*
006CC:  MOV     4218,W0
006CE:  MOV.B   #2,W0L
006D0:  MOV     W0,4218
006D2:  MOV     #4C0,W4
006D4:  MOV     W4,4216
006D6:  CALL    350
006DA:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en) 
*
005EC:  MOV     W5,[W15++]
.................... { 
....................    usb_bd_stat_t stat; 
....................  
....................    UEP(en)=ENDPT_DISABLED; 
005EE:  MOV     4226,W0
005F0:  CLR.B   1
005F2:  SL      W0,#1,W0
005F4:  MOV     #4E0,W4
005F6:  ADD     W0,W4,W5
005F8:  CLR.B   [W5]
005FA:  MOV.B   #0,W0L
005FC:  MOV.B   W0L,[W5+#1]
....................  
....................    if (usb_endpoint_is_valid(en)) 
005FE:  MOV     4226,W0
00600:  PUSH    422C
00602:  MOV.B   W0L,[W15-#2]
00604:  POP     422C
00606:  CALL    580
0060A:  CP0.B   W0L
0060C:  BRA     Z,646
....................    { 
....................       //better ping-pong support needed here 
....................       //clear state, deque if necessary 
....................       memset(&stat, 0, sizeof(usb_bd_stat_t)); 
0060E:  MOV     #4228,W1
00610:  MOV     #0,W2
00612:  REPEAT  #3
00614:  CLR.B   [W1++]
....................       UsbEpBdXSetSt(en, 0, &stat); 
00616:  MOV     4226,W0
00618:  PUSH    4234
0061A:  MOV.B   W0L,[W15-#2]
0061C:  POP     4234
0061E:  MOV     4234,W0
00620:  CLR.B   1
00622:  MOV     W0,4234
00624:  MOV     #4228,W4
00626:  MOV     W4,4236
00628:  CALL    416
....................       UsbEpBdXSetSt(en, 1, &stat); 
0062C:  MOV     4226,W0
0062E:  PUSH    4234
00630:  MOV.B   W0L,[W15-#2]
00632:  POP     4234
00634:  MOV     4234,W0
00636:  SWAP    W0
00638:  MOV.B   #1,W0L
0063A:  SWAP    W0
0063C:  MOV     W0,4234
0063E:  MOV     #4228,W4
00640:  MOV     W4,4236
00642:  CALL    416
....................    } 
00646:  MOV     [--W15],W5
00648:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    for (i=1;i<16;i++) 
0064A:  MOV     4224,W0
0064C:  MOV.B   #1,W0L
0064E:  MOV     W0,4224
00650:  MOV     4224,W0
00652:  CLR.B   1
00654:  CP.B    W0L,#10
00656:  BRA     C,672
....................       usb_disable_endpoint(i); 
00658:  MOV     4224,W0
0065A:  PUSH    4226
0065C:  MOV.B   W0L,[W15-#2]
0065E:  POP     4226
00660:  CALL    5EC
00664:  MOV     4224,W0
00666:  INC.B   W0L,W0L
00668:  PUSH    4224
0066A:  MOV.B   W0L,[W15-#2]
0066C:  POP     4224
0066E:  GOTO    650
00672:  RETURN  
....................  
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_rst(void) { 
....................    debug_usb(debug_putc,"\r\nR"); 
....................  
....................    usb_clear_isr_reg(&UEIR); 
*
00688:  MOV     #4C4,W4
0068A:  MOV     W4,420E
0068C:  CALL    4EC
....................    usb_clear_isr_reg(&UIR); 
00690:  MOV     #4C0,W4
00692:  MOV     W4,420E
00694:  CALL    4EC
....................    UEIE = 0x9F; 
00698:  MOV     #9F,W4
0069A:  MOV     W4,4C6
....................    UIE = STANDARD_INTS; 
0069C:  MOV     #99,W4
0069E:  MOV     W4,4C2
....................  
....................    UADDR=0; 
006A0:  CLR     4CC
....................  
....................    usb_token_reset(); 
006A2:  CALL    550
....................  
....................    usb_disable_endpoints(); 
006A6:  CALL    64A
....................  
....................    UEP(0) = ENDPT_CONTROL | __UEP_EPHSK; 
006AA:  MOV     #D,W4
006AC:  MOV     W4,4E0
....................  
....................    while (UIR_TRN) 
006AE:  BTSS.B  4C0.3
006B0:  BRA     6BA
....................    { 
....................       usb_clear_trn(); 
006B2:  CALL    674
006B6:  GOTO    6AE
....................    } 
....................  
....................    UCON_PKTDIS=0; //SIE token and packet processing enabled 
006BA:  BCLR.B  4CA.5
....................  
....................    usb_init_ep0_setup(); 
006BC:  CALL    448
....................  
....................    usb_state=USB_STATE_DEFAULT; //put usb mcu into default state 
006C0:  MOV.B   #3,W0L
006C2:  MOV.B   W0L,100B
006C4:  RETURN  
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void) 
.................... { 
....................    usb_bd_stat_t newBD; 
....................    usb_bd_ptr_t bdPtr; 
....................  
....................    memset(&newBD, 0x00, sizeof(newBD)); 
*
00448:  MOV     #420E,W1
0044A:  MOV     #0,W2
0044C:  REPEAT  #3
0044E:  CLR.B   [W1++]
....................    newBD.count = USB_MAX_EP0_PACKET_LENGTH; 
00450:  MOV     #40,W4
00452:  MOV     W4,4210
....................    newBD.uown = TRUE; 
00454:  MOV     420E,W0
00456:  BSET.B  0.7
00458:  MOV     W0,420E
....................   #if __PIC24_NINC_BIT__ 
....................    newBD.ninc = __PIC24_NINC_BIT__; 
....................   #endif 
....................   #if !USB_IGNORE_RX_DTS 
....................    newBD.dtsen = TRUE; 
0045A:  MOV     420E,W0
0045C:  BSET.B  0.3
0045E:  MOV     W0,420E
....................   #endif 
....................  
....................    bdPtr = USB_DATA_BUFFER_LOCATION; 
00460:  MOV     #100C,W4
00462:  MOV     W4,4212
00464:  MOV     #0,W4
00466:  MOV     W4,4214
....................    UsbEpBdXSetPtr(0, 0, &bdPtr); 
00468:  MOV     4224,W0
0046A:  MOV.B   #0,W0L
0046C:  MOV     W0,4224
0046E:  MOV     4224,W0
00470:  CLR.B   1
00472:  MOV     W0,4224
00474:  MOV     #4212,W4
00476:  MOV     W4,4226
00478:  CALL    3F2
....................  
....................    UsbEpBdXSetSt(0, 0, &newBD); 
0047C:  MOV     4234,W0
0047E:  MOV.B   #0,W0L
00480:  MOV     W0,4234
00482:  MOV     4234,W0
00484:  CLR.B   1
00486:  MOV     W0,4234
00488:  MOV     #420E,W4
0048A:  MOV     W4,4236
0048C:  CALL    416
....................  
....................    memset(&newBD, 0x00, sizeof(usb_bd_stat_t)); 
00490:  MOV     #420E,W1
00492:  MOV     #0,W2
00494:  REPEAT  #3
00496:  CLR.B   [W1++]
....................    UsbEpBdXSetSt(0, 1, &newBD); 
00498:  MOV     4234,W0
0049A:  MOV.B   #0,W0L
0049C:  MOV     W0,4234
0049E:  MOV     4234,W0
004A0:  SWAP    W0
004A2:  MOV.B   #1,W0L
004A4:  SWAP    W0
004A6:  MOV     W0,4234
004A8:  MOV     #420E,W4
004AA:  MOV     W4,4236
004AC:  CALL    416
....................  
....................    bdPtr = USB_DATA_BUFFER_LOCATION + (usb_bd_ptr_t)USB_MAX_EP0_PACKET_LENGTH; 
004B0:  MOV     #104C,W4
004B2:  MOV     W4,4212
004B4:  MOV     #0,W4
004B6:  MOV     W4,4214
....................    UsbEpBdXSetPtr(0, 1, &bdPtr); 
004B8:  MOV     4224,W0
004BA:  MOV.B   #0,W0L
004BC:  MOV     W0,4224
004BE:  MOV     4224,W0
004C0:  SWAP    W0
004C2:  MOV.B   #1,W0L
004C4:  SWAP    W0
004C6:  MOV     W0,4224
004C8:  MOV     #4212,W4
004CA:  MOV     W4,4226
004CC:  CALL    3F2
....................  
....................    debug_usb(debug_putc, "\r\nEP0 SETUP uc=%02X is=%08LX ia=%08LX os=%08LX oa=%08LX ", UCON, (unsigned int32)EP_BDxST_I(0), (unsigned int32)EP_BDxADR_I(0), (unsigned int32)EP_BDxST_O(0), EP_BDxADR_O(0)); 
004D0:  RETURN  
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) { 
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ints; 
.................... #endif 
....................  
....................    debug_usb(debug_putc,"\r\nE %02X ",UEIR); 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) ) { //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) ) {  //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) ) {  //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) ) {  //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) ) {  //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) ) { //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
.................... #endif 
....................  
....................    usb_clear_isr_reg(&UEIR); 
*
004FA:  MOV     #4C4,W4
004FC:  MOV     W4,420E
004FE:  CALL    4EC
....................    usb_clear_isr_flag(&UIR, UIE_BIT_UERR); 
00502:  MOV     4218,W0
00504:  MOV.B   #1,W0L
00506:  MOV     W0,4218
00508:  MOV     #4C0,W4
0050A:  MOV     W4,4216
0050C:  CALL    350
00510:  RETURN  
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc,"\r\nI"); 
....................  
....................    UOTGIE_ACTV=1;   //enable activity interrupt flag. 
*
006C6:  BSET.B  48A.4
....................     
....................   #if defined(__UIDLE_JAM_ERRATA__) 
....................    UIE &= ~(unsigned int16)__USB_UIF_IDLE; 
006C8:  BCLR.B  4C2.4
....................   #else 
006CA:  RETURN  
....................    usb_clear_isr_flag(&UIR, UIE_BIT_IDLE); 
....................   #endif 
....................     
....................    //UCON_SUSPND=1; //set suspend. we are now suspended 
.................... } 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc,"\r\nA"); 
....................  
....................    UCON_SUSPND=0; //turn off low power suspending 
*
00362:  BCLR.B  490.1
....................    UOTGIE_ACTV=0; //clear activity interupt enabling 
00364:  BCLR.B  48A.4
....................    usb_clear_isr_flag(&UOTGIR, UOTGIE_BIT_ACTV); 
00366:  MOV     4218,W0
00368:  MOV.B   #4,W0L
0036A:  MOV     W0,4218
0036C:  MOV     #488,W4
0036E:  MOV     W4,4216
00370:  CALL    350
....................  
....................   #if defined(__UIDLE_JAM_ERRATA__) 
....................    usb_clear_isr_flag(&UIR, UIE_BIT_IDLE); 
00374:  MOV     4218,W0
00376:  MOV.B   #4,W0L
00378:  MOV     W0,4218
0037A:  MOV     #4C0,W4
0037C:  MOV     W4,4216
0037E:  CALL    350
....................   #endif 
00382:  RETURN  
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_stall(void) 
.................... { 
....................    debug_usb(debug_putc,"\r\nS"); 
....................  
....................  
....................    if (bit_test(UEP(0),1)) { 
*
004D2:  BTSS.B  4E0.1
004D4:  BRA     4DC
....................       usb_init_ep0_setup(); 
004D6:  CALL    448
....................       bit_clear(UEP(0),1); 
004DA:  BCLR.B  4E0.1
....................    } 
....................    usb_clear_isr_flag(&UIR, UIE_BIT_STALL); 
004DC:  MOV     4218,W0
004DE:  MOV.B   #7,W0L
004E0:  MOV     W0,4218
004E2:  MOV     #4C0,W4
004E4:  MOV     W4,4216
004E6:  CALL    350
004EA:  RETURN  
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_tok_dne(void) 
*
011D6:  MOV     W5,[W15++]
.................... { 
....................    usb_bd_stat_t stat; 
....................    unsigned int8 en; 
....................    int1 tgl; 
....................  
....................    en=USTAT>>4; 
011D8:  MOV     4C8,W0
011DA:  LSR     W0,#4,W0
011DC:  PUSH    420E
011DE:  MOV.B   W0L,[W15-#2]
011E0:  POP     420E
....................  
....................    debug_usb(debug_putc,"\r\nT "); 
....................    debug_usb(debug_putc,"us%02X uc%02X ", USTAT, UCON); 
....................  
....................    if ((USTAT & 0x00F8) == USTAT_OUT_SETUP_E0) 
011E2:  MOV     4C8,W5
011E4:  AND     #F8,W5
011E6:  CP0     W5
011E8:  BRA     NZ,1366
....................    { 
....................       //new out or setup token in the buffer 
....................       unsigned int16 pidKey; 
....................  
....................       debug_usb(debug_putc,"%08LX ", (unsigned int32)EP_BDxST_O(0)); 
....................  
....................       UsbEpBdXGetSt(0, 0, &stat); 
011EA:  MOV     423A,W0
011EC:  MOV.B   #0,W0L
011EE:  MOV     W0,423A
011F0:  MOV     423A,W0
011F2:  CLR.B   1
011F4:  MOV     W0,423A
011F6:  MOV     #4210,W4
011F8:  MOV     W4,423C
011FA:  CALL    6DC
....................  
....................       pidKey = stat.pid;  //save PID 
011FE:  MOV     4210,W0
01200:  LSR     W0,#2,W4
01202:  AND     #F,W4
01204:  MOV.B   W4L,W0L
01206:  CLR.B   1
01208:  MOV     W0,4214
....................  
....................       //clear pid, prevent bdstal/pid confusion 
....................       stat.uown = 0; 
0120A:  MOV     4210,W0
0120C:  BCLR.B  0.7
0120E:  MOV     W0,4210
....................       stat.pid = 0; 
01210:  MOV     4210,W4
01212:  AND     #3C3,W4
01214:  IOR     #0,W4
01216:  PUSH    4210
01218:  MOV.B   W4L,[W15-#2]
0121A:  POP     4210
....................  
....................       UsbEpBdXSetSt(0, 0, &stat); 
0121C:  MOV     4234,W0
0121E:  MOV.B   #0,W0L
01220:  MOV     W0,4234
01222:  MOV     4234,W0
01224:  CLR.B   1
01226:  MOV     W0,4234
01228:  MOV     #4210,W4
0122A:  MOV     W4,4236
0122C:  CALL    416
....................  
....................       usb_clear_trn(); 
01230:  CALL    674
....................  
....................       if (pidKey == PID_SETUP) 
01234:  MOV     4214,W0
01236:  CP      W0,#D
01238:  BRA     NZ,1310
....................       { 
....................          // return the in buffer to us (dequeue any pending requests) 
....................          memset(&stat, 0x00, sizeof(usb_bd_stat_t)); 
0123A:  MOV     #4210,W1
0123C:  MOV     #0,W2
0123E:  REPEAT  #3
01240:  CLR.B   [W1++]
....................          UsbEpBdXSetSt(0, 1, &stat); 
01242:  MOV     4234,W0
01244:  MOV.B   #0,W0L
01246:  MOV     W0,4234
01248:  MOV     4234,W0
0124A:  SWAP    W0
0124C:  MOV.B   #1,W0L
0124E:  SWAP    W0
01250:  MOV     W0,4234
01252:  MOV     #4210,W4
01254:  MOV     W4,4236
01256:  CALL    416
....................  
....................  
....................          debug_usb(debug_putc, "%08LX ", (unsigned int32)EP_BDxST_O(0)); 
....................          debug_display_ram(EP_BDxST_O(0).count, usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0125A:  CALL    DEA
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0125E:  BCLR.B  4CA.5
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit 
....................          if (__setup_0_tx_size==0xFF) 
01260:  MOV     1118,W4
01262:  XOR.B   #FF,W4L
01264:  BRA     NZ,127E
....................             usb_flush_out(0,USB_DTS_STALL); 
01266:  MOV     4218,W0
01268:  MOV.B   #0,W0L
0126A:  MOV     W0,4218
0126C:  MOV     4218,W0
0126E:  SWAP    W0
01270:  MOV.B   #3,W0L
01272:  SWAP    W0
01274:  MOV     W0,4218
01276:  CALL    E2E
0127A:  GOTO    130C
....................          else 
....................          { 
....................             UsbEpBdXGetSt(0, 0, &stat); 
0127E:  MOV     423A,W0
01280:  MOV.B   #0,W0L
01282:  MOV     W0,423A
01284:  MOV     423A,W0
01286:  CLR.B   1
01288:  MOV     W0,423A
0128A:  MOV     #4210,W4
0128C:  MOV     W4,423C
0128E:  CALL    6DC
....................             tgl = stat.data01; 
01292:  PUSH    420E
01294:  MOV     [--W15],W4
01296:  LSR     W4,#8,W4
01298:  BCLR.B  8.0
0129A:  MOV     4210,W3
0129C:  BTSC    W3.6
0129E:  BSET.B  8.0
012A0:  PUSH    420E
012A2:  MOV.B   W4L,[W15-#1]
012A4:  POP     420E
....................             tgl = !tgl; 
012A6:  PUSH    420E
012A8:  MOV     [--W15],W4
012AA:  LSR     W4,#8,W4
012AC:  BCLR.B  8.0
012AE:  PUSH    420E
012B0:  MOV     [--W15],W3
012B2:  LSR     W3,#8,W3
012B4:  BTSS    W3.0
012B6:  BSET.B  8.0
012B8:  PUSH    420E
012BA:  MOV.B   W4L,[W15-#1]
012BC:  POP     420E
....................             usb_flush_out(0,USB_DTS_TOGGLE); 
012BE:  MOV     4218,W0
012C0:  MOV.B   #0,W0L
012C2:  MOV     W0,4218
012C4:  MOV     4218,W0
012C6:  SWAP    W0
012C8:  MOV.B   #2,W0L
012CA:  SWAP    W0
012CC:  MOV     W0,4218
012CE:  CALL    E2E
....................             if (__setup_0_tx_size!=0xFE) 
012D2:  MOV     1118,W4
012D4:  XOR.B   #FE,W4L
012D6:  BRA     Z,130C
....................             { 
....................                usb_flush_in(0, __setup_0_tx_size, tgl); 
012D8:  MOV     420E,W4
012DA:  CLR     W0
012DC:  BTSC    W4.8
012DE:  INC     W0,W0
012E0:  MOV.B   W0L,W5L
012E2:  MOV     W0,[W15++]
012E4:  MOV     4226,W0
012E6:  MOV.B   #0,W0L
012E8:  MOV     W0,4226
012EA:  MOV     [--W15],W0
012EC:  MOV     W0,[W15++]
012EE:  MOV.B   1118,W0L
012F0:  PUSH    4228
012F2:  MOV.B   W0L,[W15-#2]
012F4:  POP     4228
012F6:  MOV     [--W15],W0
012F8:  MOV     W0,[W15++]
012FA:  MOV     4228,W0
012FC:  CLR.B   1
012FE:  MOV     W0,4228
01300:  MOV     [--W15],W0
01302:  PUSH    4226
01304:  MOV.B   W5L,[W15-#1]
01306:  POP     4226
01308:  CALL    F3C
....................                //usb_flush_in(0, __setup_0_tx_size, USB_DTS_USERX); 
....................             } 
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
0130C:  GOTO    1362
....................       else if (pidKey == PID_OUT) 
01310:  MOV     4214,W0
01312:  CP      W0,#1
01314:  BRA     NZ,1362
....................       { 
....................          usb_isr_tok_out_dne(0); 
01316:  MOV     4216,W0
01318:  MOV.B   #0,W0L
0131A:  MOV     W0,4216
0131C:  CALL    109E
....................          usb_flush_out(0,USB_DTS_TOGGLE); 
01320:  MOV     4218,W0
01322:  MOV.B   #0,W0L
01324:  MOV     W0,4218
01326:  MOV     4218,W0
01328:  SWAP    W0
0132A:  MOV.B   #2,W0L
0132C:  SWAP    W0
0132E:  MOV     W0,4218
01330:  CALL    E2E
....................          if ((__setup_0_tx_size!=0xFE)&&(__setup_0_tx_size!=0xFF)) 
01334:  MOV     1118,W4
01336:  XOR.B   #FE,W4L
01338:  BRA     Z,1362
0133A:  MOV     1118,W4
0133C:  XOR.B   #FF,W4L
0133E:  BRA     Z,1362
....................                usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
01340:  MOV     4226,W0
01342:  MOV.B   #0,W0L
01344:  MOV     W0,4226
01346:  MOV.B   1118,W0L
01348:  PUSH    4228
0134A:  MOV.B   W0L,[W15-#2]
0134C:  POP     4228
0134E:  MOV     4228,W0
01350:  CLR.B   1
01352:  MOV     W0,4228
01354:  MOV     4226,W0
01356:  SWAP    W0
01358:  MOV.B   #1,W0L
0135A:  SWAP    W0
0135C:  MOV     W0,4226
0135E:  CALL    F3C
....................          debug_display_ram(16, (void*)UBDTP1 << 8); 
....................       } 
....................    } 
01362:  GOTO    13D2
....................    else if ((USTAT & 0x00F8) == USTAT_IN_E0)    //pic -> host transfer completed 
01366:  MOV     4C8,W5
01368:  AND     #F8,W5
0136A:  CP      W5,#8
0136C:  BRA     NZ,13AA
....................    { 
....................       /* 
....................       //clear up any BDSTAL confusion 
....................       UsbEpBdXGetSt(0, 1, &stat); 
....................       stat.uown = FALSE; 
....................       stat.count = 0; 
....................       stat.pid = 0; 
....................       UsbEpBdXSetSt(0, 1, &stat); 
....................       */ 
....................  
....................  
....................       usb_clear_trn(); 
0136E:  CALL    674
....................       __setup_0_tx_size=0xFF; 
01372:  SETM.B  1118
....................       usb_isr_tok_in_dne(0); 
01374:  MOV     4216,W0
01376:  MOV.B   #0,W0L
01378:  MOV     W0,4216
0137A:  CALL    11A4
....................       if (__setup_0_tx_size!=0xFF) 
0137E:  MOV     1118,W4
01380:  XOR.B   #FF,W4L
01382:  BRA     Z,13A6
....................          usb_flush_in(0,__setup_0_tx_size,USB_DTS_TOGGLE); 
01384:  MOV     4226,W0
01386:  MOV.B   #0,W0L
01388:  MOV     W0,4226
0138A:  MOV.B   1118,W0L
0138C:  PUSH    4228
0138E:  MOV.B   W0L,[W15-#2]
01390:  POP     4228
01392:  MOV     4228,W0
01394:  CLR.B   1
01396:  MOV     W0,4228
01398:  MOV     4226,W0
0139A:  SWAP    W0
0139C:  MOV.B   #2,W0L
0139E:  SWAP    W0
013A0:  MOV     W0,4226
013A2:  CALL    F3C
....................       //else 
....................       //   usb_init_ep0_setup(); 
....................    } 
013A6:  GOTO    13D2
....................    else 
....................    { 
....................       if (!bit_test(USTAT, 3)) 
013AA:  BTSC.B  4C8.3
013AC:  BRA     13C2
....................       { 
....................          /* 
....................          //clear up any BDSTAL confusion 
....................          UsbEpBdXGetSt(en, 0, &stat); 
....................          stat.uown = FALSE; 
....................          stat.pid = 0; 
....................          UsbEpBdXSetSt(en, 0, &stat); 
....................          */ 
....................  
....................          usb_clear_trn(); 
013AE:  CALL    674
....................          usb_isr_tok_out_dne(en); 
013B2:  MOV     420E,W0
013B4:  PUSH    4216
013B6:  MOV.B   W0L,[W15-#2]
013B8:  POP     4216
013BA:  CALL    109E
....................       } 
013BE:  GOTO    13D2
....................       else 
....................       { 
....................          /* 
....................          //clear up any BDSTAL confusion 
....................          UsbEpBdXGetSt(en, 1, &stat); 
....................          stat.uown = FALSE; 
....................          stat.count = 0; 
....................          stat.pid = 0; 
....................          UsbEpBdXSetSt(en, 1, &stat); 
....................          */ 
....................  
....................          usb_clear_trn(); 
013C2:  CALL    674
....................          usb_isr_tok_in_dne(en); 
013C6:  MOV     420E,W0
013C8:  PUSH    4216
013CA:  MOV.B   W0L,[W15-#2]
013CC:  POP     4216
013CE:  CALL    11A4
....................       } 
....................    } 
013D2:  MOV     [--W15],W5
013D4:  RETURN  
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size=len;} 
*
0070E:  MOV     421C,W0
00710:  MOV.B   W0L,1118
00712:  RETURN  
.................... void usb_request_get_data(void) {__setup_0_tx_size=0xFE;} 
*
00D3A:  MOV.B   #FE,W0L
00D3C:  MOV.B   W0L,1118
00D3E:  RETURN  
.................... void usb_request_stall(void) {__setup_0_tx_size=0xFF;} 
*
00714:  SETM.B  1118
00716:  RETURN  
....................  
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... static void usb_clear_isr_flag(unsigned int16 *sfr, unsigned int8 bit) 
*
00350:  MOV     W5,[W15++]
.................... { 
....................    *sfr = (int16)1 << bit; 
00352:  MOV     4216,W5
00354:  MOV     4218,W4
00356:  CLR.B   9
00358:  MOV     #1,W0
0035A:  SL      W0,W4,W0
0035C:  MOV     W0,[W5]
0035E:  MOV     [--W15],W5
00360:  RETURN  
.................... } 
....................  
.................... static void usb_clear_isr_reg(unsigned int16 *sfr) 
*
004EC:  MOV     W5,[W15++]
.................... { 
....................    *sfr = 0xFFFF; 
004EE:  MOV     420E,W5
004F0:  SETM.B  [W5]
004F2:  MOV.B   #FF,W0L
004F4:  MOV.B   W0L,[W5+#1]
004F6:  MOV     [--W15],W5
004F8:  RETURN  
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1)) 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  64 
.................... #else 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  8 
.................... #endif 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          len = packet_size; 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
*
00550:  MOV     W5,[W15++]
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
00552:  CLR     111C
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
00554:  MOV     #0,W4
00556:  MOV     W4,420E
00558:  MOV     420E,W0
0055A:  CP      W0,#2
0055C:  BRA     C,570
....................       USB_Interface[i] = 0;   //reset each interface to default 
0055E:  MOV     420E,W0
00560:  MOV     #111E,W4
00562:  ADD     W0,W4,W5
00564:  CLR.B   [W5]
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
00566:  MOV     420E,W0
00568:  INC     W0,W0
0056A:  MOV     W0,420E
0056C:  GOTO    558
....................    usb_cdc_init(); 
00570:  CALL    512
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
00574:  CLR     1002
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
00576:  MOV     #1,W4
00578:  MOV     W4,1004
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
0057A:  CLR.B   1000
0057C:  MOV     [--W15],W5
0057E:  RETURN  
.................... } 
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
00580:  MOV     W5,[W15++]
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
00582:  PUSH    422C
00584:  MOV     [--W15],W4
00586:  LSR     W4,#8,W4
00588:  BCLR.B  8.0
0058A:  MOV     422C,W3
0058C:  BTSC    W3.7
0058E:  BSET.B  8.0
00590:  PUSH    422C
00592:  MOV.B   W4L,[W15-#1]
00594:  POP     422C
....................     
....................    endpoint &= 0x7F; 
00596:  MOV     422C,W0
00598:  CLR.B   1
0059A:  BCLR    W0.7
0059C:  PUSH    422C
0059E:  MOV.B   W0L,[W15-#2]
005A0:  POP     422C
....................     
....................    if (endpoint > 16) 
005A2:  MOV     422C,W0
005A4:  CLR.B   1
005A6:  CP.B    W0L,#10
005A8:  BRA     LEU,5AE
....................       return(FALSE); 
005AA:  CLR.B   0
005AC:  BRA     5E8
....................     
....................    if (direction) { //IN 
005AE:  MOV     422C,W4
005B0:  BTSS    W4.8
005B2:  BRA     5D0
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
005B4:  MOV     422C,W0
005B6:  CLR.B   1
005B8:  CALL    200
005BC:  MOV     #FF,W4
005BE:  CP.B    W4L,W0L
005C0:  BRA     NZ,5C8
005C2:  CLR.B   W0
005C4:  GOTO    5CA
005C8:  MOV.B   #1,W0L
005CA:  BRA     5E8
....................    } 
005CC:  GOTO    5E8
....................    else {   //OUT 
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
005D0:  MOV     422C,W0
005D2:  CLR.B   1
005D4:  CALL    21C
005D8:  MOV     #FF,W4
005DA:  CP.B    W4L,W0L
005DC:  BRA     NZ,5E4
005DE:  CLR.B   W0
005E0:  GOTO    5E6
005E4:  MOV.B   #1,W0L
005E6:  BRA     5E8
....................    } 
005E8:  MOV     [--W15],W5
005EA:  RETURN  
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
011A4:  MOV     4216,W0
011A6:  CLR.B   1
011A8:  CP0.B   W0L
011AA:  BRA     NZ,11C8
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
011AC:  MOV     1000,W4
011AE:  CP.B    W4L,#1
011B0:  BRA     NZ,11BA
011B2:  CALL    718
011B6:  GOTO    11C4
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
011BA:  MOV     1000,W4
011BC:  CP.B    W4L,#2
011BE:  BRA     NZ,11C4
011C0:  CALL    10D8
....................    } 
....................   #if USB_CDC_DEVICE 
011C4:  GOTO    11D4
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
011C8:  MOV     4216,W0
011CA:  CLR.B   1
011CC:  CP.B    W0L,#2
011CE:  BRA     NZ,11D4
....................       usb_isr_tok_in_cdc_data_dne(); 
011D0:  CALL    119E
....................   } 
....................   #endif 
011D4:  RETURN  
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0109E:  MOV     4216,W0
010A0:  CLR.B   1
010A2:  CP0.B   W0L
010A4:  BRA     NZ,10AE
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
010A6:  CALL    1012
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
010AA:  GOTO    10BA
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
010AE:  MOV     4216,W0
010B0:  CLR.B   1
010B2:  CP.B    W0L,#2
010B4:  BRA     NZ,10BA
....................       usb_isr_tok_out_cdc_data_dne(); 
010B6:  CALL    1084
....................    } 
....................   #endif 
010BA:  RETURN  
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
00DEA:  CLR.B   1000
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
00DEC:  MOV.B   100C,W0L
00DEE:  CLR.B   1
00DF0:  AND     #7F,W0
00DF2:  XOR     #0,W0
00DF4:  BRA     Z,E04
00DF6:  XOR     #1,W0
00DF8:  BRA     Z,E0C
00DFA:  XOR     #3,W0
00DFC:  BRA     Z,E14
00DFE:  XOR     #23,W0
00E00:  BRA     Z,E1C
00E02:  BRA     E24
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb_token(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
00E04:  CALL    9F8
....................          break; 
00E08:  GOTO    E2C
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb_token(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
00E0C:  CALL    AD0
....................          break; 
00E10:  GOTO    E2C
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb_token(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
00E14:  CALL    CB4
....................          break; 
00E18:  GOTO    E2C
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb_token(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
00E1C:  CALL    D40
....................         #endif 
....................          break; 
00E20:  GOTO    E2C
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
00E24:  CALL    714
....................          break; 
00E28:  GOTO    E2C
....................    } 
00E2C:  RETURN  
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
009F8:  MOV.B   100D,W0L
009FA:  CLR.B   1
009FC:  XOR     #0,W0
009FE:  BRA     Z,A1A
00A00:  XOR     #1,W0
00A02:  BRA     Z,A2E
00A04:  XOR     #2,W0
00A06:  BRA     Z,A50
00A08:  XOR     #6,W0
00A0A:  BRA     Z,A70
00A0C:  XOR     #3,W0
00A0E:  BRA     Z,A86
00A10:  XOR     #E,W0
00A12:  BRA     Z,A8E
00A14:  XOR     #1,W0
00A16:  BRA     Z,AA0
00A18:  BRA     AC6
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb_token(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
00A1A:  MOV.B   1004,W0L
00A1C:  MOV.B   W0L,104C
....................             usb_ep0_tx_buffer[1]=0; 
00A1E:  CLR.B   104D
....................             usb_request_send_response(2); 
00A20:  MOV     421C,W0
00A22:  MOV.B   #2,W0L
00A24:  MOV     W0,421C
00A26:  CALL    70E
....................             break; 
00A2A:  GOTO    ACE
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
00A2E:  MOV     100E,W4
00A30:  CP.B    W4L,#1
00A32:  BRA     NZ,A48
....................                debug_usb_token(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
00A34:  MOV     1004,W0
00A36:  AND     W0,#1,W0
00A38:  MOV     W0,1004
....................                usb_put_0len_0(); 
00A3A:  MOV     421C,W0
00A3C:  MOV.B   #0,W0L
00A3E:  MOV     W0,421C
00A40:  CALL    70E
....................             } 
00A44:  GOTO    A4C
....................             else 
....................                usb_request_stall(); 
00A48:  CALL    714
....................             break; 
00A4C:  GOTO    ACE
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
00A50:  MOV     100E,W4
00A52:  CP.B    W4L,#1
00A54:  BRA     NZ,A68
....................                debug_usb_token(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
00A56:  MOV     #1004,W4
00A58:  BSET    [W4].1
....................                usb_put_0len_0(); 
00A5A:  MOV     421C,W0
00A5C:  MOV.B   #0,W0L
00A5E:  MOV     W0,421C
00A60:  CALL    70E
....................             } 
00A64:  GOTO    A6C
....................             else 
....................                usb_request_stall(); 
00A68:  CALL    714
....................             break; 
00A6C:  GOTO    ACE
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb_token(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
00A70:  MOV.B   #2,W0L
00A72:  MOV.B   W0L,1000
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
00A74:  MOV.B   100E,W0L
00A76:  MOV.B   W0L,1119
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
00A78:  MOV     421C,W0
00A7A:  MOV.B   #0,W0L
00A7C:  MOV     W0,421C
00A7E:  CALL    70E
....................             break; 
00A82:  GOTO    ACE
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb_token(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
00A86:  CALL    7AA
....................             break; 
00A8A:  GOTO    ACE
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb_token(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
00A8E:  MOV.B   1002,W0L
00A90:  MOV.B   W0L,104C
....................             usb_request_send_response(1); 
00A92:  MOV     421C,W0
00A94:  MOV.B   #1,W0L
00A96:  MOV     W0,421C
00A98:  CALL    70E
....................             break; 
00A9C:  GOTO    ACE
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
00AA0:  MOV     100E,W4
00AA2:  CP.B    W4L,#1
00AA4:  BRA     GTU,AC2
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
00AA6:  MOV.B   100E,W0L
00AA8:  MOV.B   W0L,1002
00AAA:  CLR.B   1003
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
00AAC:  MOV.B   100E,W0L
00AAE:  PUSH    4216
00AB0:  MOV.B   W0L,[W15-#2]
00AB2:  POP     4216
00AB4:  CALL    86C
....................                debug_usb_token(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
00AB8:  MOV     421C,W0
00ABA:  MOV.B   #0,W0L
00ABC:  MOV     W0,421C
00ABE:  CALL    70E
....................             } 
....................             break; 
00AC2:  GOTO    ACE
....................  
....................       default: 
....................             usb_request_stall(); 
00AC6:  CALL    714
....................             break; 
00ACA:  GOTO    ACE
....................    } 
00ACE:  RETURN  
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
00AD0:  MOV     W5,[W15++]
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
00AD2:  MOV.B   1002,W0L
00AD4:  PUSH    4216
00AD6:  MOV.B   W0L,[W15-#2]
00AD8:  POP     4216
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
00ADA:  MOV.B   100D,W0L
00ADC:  CLR.B   1
00ADE:  XOR     #0,W0
00AE0:  BRA     Z,AEC
00AE2:  XOR     #A,W0
00AE4:  BRA     Z,AFE
00AE6:  XOR     #1,W0
00AE8:  BRA     Z,B3C
00AEA:  BRA     B66
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb_token(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
00AEC:  CLR.B   104C
....................             usb_ep0_tx_buffer[1]=0; 
00AEE:  CLR.B   104D
....................             usb_request_send_response(2); 
00AF0:  MOV     421C,W0
00AF2:  MOV.B   #2,W0L
00AF4:  MOV     W0,421C
00AF6:  CALL    70E
....................             break; 
00AFA:  GOTO    B6E
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
00AFE:  MOV     4216,W0
00B00:  CLR.B   1
00B02:  CP0.B   W0L
00B04:  BRA     Z,B34
00B06:  MOV     4216,W4
00B08:  CLR.B   9
00B0A:  SUB     W4,#1,W5
00B0C:  MOV     W5,W0
00B0E:  CALL    2D6
00B12:  MOV     1010,W4
00B14:  CP.B    W4L,W0L
00B16:  BRA     GE,B34
....................                debug_usb_token(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
00B18:  MOV     1010,W4
00B1A:  CLR.B   9
00B1C:  MOV     #111E,W3
00B1E:  ADD     W4,W3,W0
00B20:  MOV     104C,W4
00B22:  MOV.B   [W0+#0],W4L
00B24:  MOV     W4,104C
....................                usb_request_send_response(1); //send byte back 
00B26:  MOV     421C,W0
00B28:  MOV.B   #1,W0L
00B2A:  MOV     W0,421C
00B2C:  CALL    70E
....................             } 
00B30:  GOTO    B38
....................             else 
....................                usb_request_stall(); 
00B34:  CALL    714
....................             break; 
00B38:  GOTO    B6E
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
00B3C:  MOV     4216,W0
00B3E:  CLR.B   1
00B40:  CP0.B   W0L
00B42:  BRA     Z,B5E
....................                debug_usb_token(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
00B44:  MOV     1010,W4
00B46:  CLR.B   9
00B48:  MOV     #111E,W3
00B4A:  ADD     W4,W3,W5
00B4C:  MOV     100E,W0
00B4E:  MOV.B   W0L,[W5+#0]
....................                usb_put_0len_0(); 
00B50:  MOV     421C,W0
00B52:  MOV.B   #0,W0L
00B54:  MOV     W0,421C
00B56:  CALL    70E
....................             } 
00B5A:  GOTO    B62
....................             else 
....................                usb_request_stall(); 
00B5E:  CALL    714
....................             break; 
00B62:  GOTO    B6E
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb_token(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
00B66:  CALL    714
....................             break; 
00B6A:  GOTO    B6E
....................    } 
00B6E:  MOV     [--W15],W5
00B70:  RETURN  
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
00CB4:  MOV.B   1010,W0L
00CB6:  PUSH    422C
00CB8:  MOV.B   W0L,[W15-#2]
00CBA:  POP     422C
00CBC:  CALL    580
00CC0:  CP0.B   W0L
00CC2:  BRA     Z,D38
....................       switch(usb_ep0_rx_buffer[1]) { 
00CC4:  MOV.B   100D,W0L
00CC6:  CLR.B   1
00CC8:  XOR     #1,W0
00CCA:  BRA     Z,CD6
00CCC:  XOR     #2,W0
00CCE:  BRA     Z,CF0
00CD0:  XOR     #3,W0
00CD2:  BRA     Z,D0A
00CD4:  BRA     D30
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb_token(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
00CD6:  MOV.B   1010,W0L
00CD8:  PUSH    4216
00CDA:  MOV.B   W0L,[W15-#2]
00CDC:  POP     4216
00CDE:  CALL    B72
....................                usb_put_0len_0(); 
00CE2:  MOV     421C,W0
00CE4:  MOV.B   #0,W0L
00CE6:  MOV     W0,421C
00CE8:  CALL    70E
....................                break; 
00CEC:  GOTO    D38
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb_token(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
00CF0:  MOV.B   1010,W0L
00CF2:  PUSH    4216
00CF4:  MOV.B   W0L,[W15-#2]
00CF6:  POP     4216
00CF8:  CALL    BF8
....................                      usb_put_0len_0(); 
00CFC:  MOV     421C,W0
00CFE:  MOV.B   #0,W0L
00D00:  MOV     W0,421C
00D02:  CALL    70E
....................                      break; 
00D06:  GOTO    D38
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb_token(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
00D0A:  CLR.B   104C
....................                usb_ep0_tx_buffer[1]=0; 
00D0C:  CLR.B   104D
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
00D0E:  MOV.B   1010,W0L
00D10:  PUSH    4216
00D12:  MOV.B   W0L,[W15-#2]
00D14:  POP     4216
00D16:  CALL    C56
00D1A:  CP0.B   W0L
00D1C:  BRA     Z,D22
....................                   usb_ep0_tx_buffer[0]=1; 
00D1E:  MOV.B   #1,W0L
00D20:  MOV.B   W0L,104C
....................                } 
....................                usb_request_send_response(2); 
00D22:  MOV     421C,W0
00D24:  MOV.B   #2,W0L
00D26:  MOV     W0,421C
00D28:  CALL    70E
....................                break; 
00D2C:  GOTO    D38
....................  
....................          default: 
....................             usb_request_stall(); 
00D30:  CALL    714
....................             break; 
00D34:  GOTO    D38
....................       } 
....................    } 
00D38:  RETURN  
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb_token(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb_token(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
*
007AA:  MOV     W5,[W15++]
007AC:  MOV     4216,W0
007AE:  MOV.B   #0,W0L
007B0:  MOV     W0,4216
....................    unsigned int8 i = 0; 
....................    usb_getdesc_ptr=0; 
007B2:  CLR     111A
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
007B4:  CLR.B   1006
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
007B6:  MOV.B   100F,W0L
007B8:  CLR.B   1
007BA:  XOR     #1,W0
007BC:  BRA     Z,7CC
007BE:  XOR     #3,W0
007C0:  BRA     Z,7D8
007C2:  XOR     #1,W0
007C4:  BRA     Z,7E0
007C6:  XOR     #22,W0
007C8:  BRA     Z,81C
007CA:  BRA     846
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
007CC:  MOV     #12,W4
007CE:  MOV     W4,111C
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
007D0:  MOV.B   #3,W0L
007D2:  MOV.B   W0L,1006
....................             break; 
007D4:  GOTO    84C
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
007D8:  MOV     #43,W4
007DA:  MOV     W4,111C
....................             break; 
007DC:  GOTO    84C
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
007E0:  MOV.B   #2,W0L
007E2:  MOV.B   W0L,1006
....................             //usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
....................             for(i=0; i<usb_ep0_rx_buffer[2]; i++) 
007E4:  MOV     4216,W0
007E6:  MOV.B   #0,W0L
007E8:  MOV     W0,4216
007EA:  MOV     4216,W0
007EC:  CLR.B   1
007EE:  MOV     100E,W4
007F0:  CP.B    W4L,W0L
007F2:  BRA     LEU,80E
....................             { 
....................                usb_getdesc_ptr += USB_STRING_DESC[usb_getdesc_ptr]; 
007F4:  MOV     111A,W0
007F6:  CALL    316
007FA:  MOV.B   W0L,W5L
007FC:  SE      W5,W0
007FE:  ADD     111A
00800:  MOV     4216,W0
00802:  INC.B   W0L,W0L
00804:  PUSH    4216
00806:  MOV.B   W0L,[W15-#2]
00808:  POP     4216
0080A:  GOTO    7EA
....................             } 
....................             usb_getdesc_len = USB_STRING_DESC[usb_getdesc_ptr]; 
0080E:  MOV     111A,W0
00810:  CALL    316
00814:  SE      W0,W0
00816:  MOV     W0,111C
....................             break; 
00818:  GOTO    84C
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
0081C:  MOV.B   100E,W0L
0081E:  CLR.B   1
00820:  CALL    2E4
00824:  SE      W0,W0
00826:  MOV     W0,111A
....................             if (usb_getdesc_ptr!=0xFF) { 
00828:  MOV     111A,W4
0082A:  XOR     #FF,W4
0082C:  BRA     Z,840
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0082E:  MOV     111A,W0
00830:  CALL    28C
00834:  SE      W0,W0
00836:  MOV     W0,111C
....................                break; 
00838:  GOTO    84C
....................             } 
0083C:  GOTO    846
....................             else { 
....................                usb_request_stall(); 
00840:  CALL    714
....................                return; 
00844:  BRA     868
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
00846:  CALL    714
....................             return; 
0084A:  BRA     868
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
0084C:  CP0.B   1013
0084E:  BRA     NZ,860
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
00850:  MOV.B   1012,W0L
00852:  CLR.B   1
00854:  MOV     111C,W4
00856:  CP      W4,W0
00858:  BRA     LEU,860
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
0085A:  MOV.B   1012,W0L
0085C:  MOV.B   W0L,111C
0085E:  CLR.B   111D
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
00860:  MOV.B   #1,W0L
00862:  MOV.B   W0L,1000
....................    usb_copy_desc_seg_to_ep(); 
00864:  CALL    718
00868:  MOV     [--W15],W5
0086A:  RETURN  
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb_token(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
010D8:  CLR     1002
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
010DA:  CLR.B   1000
....................    usb_set_address(USB_address_pending); 
010DC:  MOV.B   1119,W0L
010DE:  PUSH    4218
010E0:  MOV.B   W0L,[W15-#2]
010E2:  POP     4218
010E4:  CALL    10BC
....................    #endif 
010E8:  RETURN  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
00718:  MOV     W5,[W15++]
0071A:  MOV     W6,[W15++]
0071C:  MOV     #0,W4
0071E:  MOV     W4,421A
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
00720:  CP0     111C
00722:  BRA     Z,78A
00724:  MOV     421A,W0
00726:  MOV     #40,W4
00728:  CP      W4,W0
0072A:  BRA     LEU,78A
....................    { 
....................       switch(USB_stack_status.getdesc_type) { 
0072C:  MOV.B   1006,W0L
0072E:  CLR.B   1
00730:  XOR     #0,W0
00732:  BRA     Z,73E
00734:  XOR     #2,W0
00736:  BRA     Z,74E
00738:  XOR     #1,W0
0073A:  BRA     Z,75E
0073C:  BRA     76E
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0073E:  MOV     111A,W0
00740:  CALL    28C
00744:  PUSH    4218
00746:  MOV.B   W0L,[W15-#2]
00748:  POP     4218
....................             break; 
0074A:  GOTO    76E
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
0074E:  MOV     111A,W0
00750:  CALL    316
00754:  PUSH    4218
00756:  MOV.B   W0L,[W15-#2]
00758:  POP     4218
....................             break; 
0075A:  GOTO    76E
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
0075E:  MOV     111A,W0
00760:  CALL    2F8
00764:  PUSH    4218
00766:  MOV.B   W0L,[W15-#2]
00768:  POP     4218
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
0076A:  GOTO    76E
....................       } 
....................       usb_getdesc_ptr++; 
0076E:  INC     111A
....................       usb_getdesc_len--; 
00770:  DEC     111C
....................       usb_ep0_tx_buffer[i++]=c; 
00772:  MOV     421A,W0
00774:  MOV     W0,[W15++]
00776:  INC     W0,W0
00778:  MOV     W0,421A
0077A:  MOV     [--W15],W0
0077C:  MOV     W0,W5
0077E:  MOV     #104C,W4
00780:  ADD     W5,W4,W6
00782:  MOV     4218,W0
00784:  MOV.B   W0L,[W6+#0]
00786:  GOTO    720
....................    } 
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
0078A:  CP0     111C
0078C:  BRA     NZ,798
0078E:  MOV     421A,W0
00790:  MOV     #40,W4
00792:  CP      W4,W0
00794:  BRA     Z,798
....................          USB_stack_status.dev_req = NONE; 
00796:  CLR.B   1000
....................    } 
....................  
....................    usb_request_send_response(i); 
00798:  MOV     421A,W0
0079A:  PUSH    421C
0079C:  MOV.B   W0L,[W15-#2]
0079E:  POP     421C
007A0:  CALL    70E
007A4:  MOV     [--W15],W6
007A6:  MOV     [--W15],W5
007A8:  RETURN  
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /* 
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary 
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk 
....................    transfer endpoints is not supported on slow speed devices per the USB 
....................    specification.  You may be able to find unofficial drivers for your 
....................    operating system that allows CDC to operate on a slow speed device, 
....................    but CCS doesn't have any that they can recommend to you. 
.................... */ 
.................... #if (USB_USE_FULL_SPEED==0) 
....................    #error CDC and slow speed is not supported.  See comments above. 
.................... #endif 
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... #ifndef USB_CDC_DATA_LOCAL_SIZE 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #else 
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_LOCAL_SIZE]; 
.................... #endif 
....................  
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this. 
....................  typedef unsigned int16 usb_cdc_tx_t; 
.................... #else 
....................  typedef unsigned int8 usb_cdc_tx_t; 
.................... #endif 
....................  
.................... usb_cdc_tx_t usb_cdc_put_buffer_nextin; 
.................... //#locate usb_cdc_put_buffer_nextin=0x1800 
....................  
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state; 
....................  
.................... /* 
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
.................... */ 
....................  
.................... #if defined(USB_CDC_USE_ENCAPSULATED) 
.................... unsigned int16 g_UsbCdcSendEncapsSize; 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void)  
.................... { 
....................    switch (__usb_cdc_state) { 
*
01012:  MOV.B   116B,W0L
01014:  CLR.B   1
01016:  XOR     #1,W0
01018:  BRA     Z,1020
0101A:  XOR     #3,W0
0101C:  BRA     Z,1030
0101E:  BRA     1048
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................         #if defined(USB_CDC_USE_ENCAPSULATED) 
....................          usb_cdc_SendEncapsulatedCommand(usb_ep0_rx_buffer, g_UsbCdcSendEncapsSize); 
....................         #endif 
....................          usb_put_0len_0(); 
01020:  MOV     421C,W0
01022:  MOV.B   #0,W0L
01024:  MOV     W0,421C
01026:  CALL    70E
....................          __usb_cdc_state=0; 
0102A:  CLR.B   116B
....................          break; 
0102C:  GOTO    104E
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
01030:  MOV     #1120,W1
01032:  MOV     #100C,W2
01034:  REPEAT  #6
01036:  MOV.B   [W2++],[W1++]
....................          __usb_cdc_state=0; 
01038:  CLR.B   116B
....................          usb_put_0len_0(); 
0103A:  MOV     421C,W0
0103C:  MOV.B   #0,W0L
0103E:  MOV     W0,421C
01040:  CALL    70E
....................          break; 
01044:  GOTO    104E
....................  
....................       default: 
....................          __usb_cdc_state=0; 
01048:  CLR.B   116B
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
0104A:  GOTO    104E
....................    } 
0104E:  RETURN  
.................... } 
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    unsigned int16 wLen; 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
00D40:  MOV     1010,W4
00D42:  CP.B    W4L,#1
00D44:  BRA     Z,D4A
00D46:  CP0.B   1010
00D48:  BRA     NZ,DE8
....................       wLen = make16(usb_ep0_rx_buffer[7], usb_ep0_rx_buffer[6]); 
00D4A:  MOV.B   1012,W0L
00D4C:  PUSH    4216
00D4E:  MOV.B   W0L,[W15-#2]
00D50:  POP     4216
00D52:  MOV.B   1013,W0L
00D54:  PUSH    4216
00D56:  MOV.B   W0L,[W15-#1]
00D58:  POP     4216
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
00D5A:  MOV.B   100D,W0L
00D5C:  CLR.B   1
00D5E:  XOR     #0,W0
00D60:  BRA     Z,D78
00D62:  XOR     #1,W0
00D64:  BRA     Z,D84
00D66:  XOR     #21,W0
00D68:  BRA     Z,D94
00D6A:  XOR     #1,W0
00D6C:  BRA     Z,DA2
00D6E:  XOR     #3,W0
00D70:  BRA     Z,DB8
00D72:  XOR     #1,W0
00D74:  BRA     Z,DCA
00D76:  BRA     DE0
....................          case 0x00:  //send_encapsulated_command 
....................            #if defined(USB_CDC_USE_ENCAPSULATED) 
....................             g_UsbCdcSendEncapsSize = wLen; 
....................            #endif 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
00D78:  MOV.B   #1,W0L
00D7A:  MOV.B   W0L,116B
....................             usb_request_get_data(); 
00D7C:  CALL    D3A
....................             break; 
00D80:  GOTO    DE8
....................  
....................          case 0x01:  //get_encapsulated_command 
....................            #if defined(USB_CDC_USE_ENCAPSULATED) 
....................             usb_cdc_GetEncapsulatedResponse(usb_ep0_tx_buffer, wLen); 
....................            #endif 
....................             usb_request_send_response(wLen); 
00D84:  MOV     4216,W0
00D86:  PUSH    421C
00D88:  MOV.B   W0L,[W15-#2]
00D8A:  POP     421C
00D8C:  CALL    70E
....................             break; 
00D90:  GOTO    DE8
....................  
....................          case 0x20:  //set_line_coding 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
00D94:  MOV.B   #2,W0L
00D96:  MOV.B   W0L,116B
....................             usb_cdc_got_set_line_coding=TRUE; 
00D98:  BSET.B  1169.0
....................             usb_request_get_data(); 
00D9A:  CALL    D3A
....................             break; 
00D9E:  GOTO    DE8
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
00DA2:  MOV     #104C,W1
00DA4:  MOV     #1120,W2
00DA6:  REPEAT  #6
00DA8:  MOV.B   [W2++],[W1++]
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
00DAA:  MOV     421C,W0
00DAC:  MOV.B   #7,W0L
00DAE:  MOV     W0,421C
00DB0:  CALL    70E
....................             break; 
00DB4:  GOTO    DE8
....................  
....................          case 0x22:  //set_control_line_state 
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
00DB8:  MOV.B   100E,W0L
00DBA:  MOV.B   W0L,116A
....................             usb_put_0len_0(); 
00DBC:  MOV     421C,W0
00DBE:  MOV.B   #0,W0L
00DC0:  MOV     W0,421C
00DC2:  CALL    70E
....................             break; 
00DC6:  GOTO    DE8
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
00DCA:  MOV.B   100F,W0L
00DCC:  MOV.B   W0L,1128
00DCE:  MOV.B   100E,W0L
00DD0:  MOV.B   W0L,1129
....................             usb_put_0len_0(); 
00DD2:  MOV     421C,W0
00DD4:  MOV.B   #0,W0L
00DD6:  MOV     W0,421C
00DD8:  CALL    70E
....................             break; 
00DDC:  GOTO    DE8
....................  
....................          default: 
....................             usb_request_stall(); 
00DE0:  CALL    714
....................             break; 
00DE4:  GOTO    DE8
....................       } 
....................    } 
00DE8:  RETURN  
.................... } 
....................  
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
01084:  BSET.B  1008.0
....................    usb_cdc_get_buffer_status.index=0; 
01086:  CLR.B   100A
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
01088:  MOV     4218,W0
0108A:  MOV.B   #2,W0L
0108C:  MOV     W0,4218
0108E:  CALL    1050
01092:  MOV.B   W0L,1009
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
01094:  CP0.B   1009
01096:  BRA     NZ,109C
....................    { 
....................       usb_cdc_get_discard(); 
01098:  CALL    106C
....................    } 
0109C:  RETURN  
....................    /* 
....................   #if defined(USB_CDC_ISR) 
....................    else 
....................    { 
....................       USB_CDC_ISR(); 
....................    } 
....................   #endif 
....................   */ 
.................... } 
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    usb_cdc_flush_tx_buffer(); 
*
0119E:  CALL    116C
011A2:  RETURN  
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... void usb_cdc_flush_tx_buffer(void)  
.................... { 
....................   #ifdef USB_CDC_DATA_LOCAL_SIZE 
....................    usb_cdc_tx_t n; 
....................   #endif 
....................    
....................    if (usb_cdc_put_buffer_nextin != 0) 
*
0116C:  CP0.B   1127
0116E:  BRA     Z,119C
....................    { 
....................      #ifndef USB_CDC_DATA_LOCAL_SIZE 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE)) 
01170:  MOV     421A,W0
01172:  MOV.B   #2,W0L
01174:  MOV     W0,421A
01176:  MOV.B   1127,W0L
01178:  PUSH    421E
0117A:  MOV.B   W0L,[W15-#2]
0117C:  POP     421E
0117E:  MOV     421E,W0
01180:  CLR.B   1
01182:  MOV     W0,421E
01184:  MOV     421A,W0
01186:  SWAP    W0
01188:  MOV.B   #2,W0L
0118A:  SWAP    W0
0118C:  MOV     W0,421A
0118E:  MOV     #112A,W4
01190:  MOV     W4,421C
01192:  CALL    110E
01196:  CP0.B   W0L
01198:  BRA     Z,119C
....................       { 
....................          usb_cdc_put_buffer_nextin = 0; 
0119A:  CLR.B   1127
....................       } 
....................      #else 
....................       n = usb_cdc_put_buffer_nextin; 
....................       if (n > (USB_CDC_DATA_IN_SIZE-1)) //always send one less than packet size so we don't have to deal with 0 len packets 
....................          n = USB_CDC_DATA_IN_SIZE-1; 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,n,USB_DTS_TOGGLE)) 
....................       { 
....................          //pull the buffer back 
....................          memmove(usb_cdc_put_buffer, &usb_cdc_put_buffer[n], usb_cdc_put_buffer_nextin-n); 
....................          usb_cdc_put_buffer_nextin -= n; 
....................       }       
....................      #endif 
....................    } 
0119C:  RETURN  
.................... } 
....................  
.................... void usb_cdc_init(void)  
*
00512:  MOV     W5,[W15++]
00514:  MOV     W6,[W15++]
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
00516:  MOV     #2580,W5
00518:  MOV     #0,W6
0051A:  MOV     #1120,W1
0051C:  MOV     #A,W2
0051E:  REPEAT  #1
00520:  MOV.B   [W2++],[W1++]
00522:  CLR.B   1122
00524:  CLR.B   1123
....................    usb_cdc_line_coding.bCharFormat = 0; 
00526:  CLR.B   W5
00528:  MOV     #1124,W1
0052A:  MOV     #A,W2
0052C:  MOV.B   [W2++],[W1++]
....................    usb_cdc_line_coding.bParityType = 0; 
0052E:  CLR.B   W5
00530:  MOV     #1125,W1
00532:  MOV     #A,W2
00534:  MOV.B   [W2++],[W1++]
....................    usb_cdc_line_coding.bDataBits = 8; 
00536:  MOV.B   #8,W5L
00538:  MOV     #1126,W1
0053A:  MOV     #A,W2
0053C:  MOV.B   [W2++],[W1++]
....................    (int8)usb_cdc_carrier = 0; 
0053E:  CLR.B   116A
....................    usb_cdc_got_set_line_coding = FALSE; 
00540:  BCLR.B  1169.0
....................    usb_cdc_break = 0; 
00542:  CLR     1128
....................    usb_cdc_put_buffer_nextin = 0; 
00544:  CLR.B   1127
....................    usb_cdc_get_buffer_status.got = 0; 
00546:  BCLR.B  1008.0
....................    __usb_cdc_state = 0; 
00548:  CLR.B   116B
0054A:  MOV     [--W15],W6
0054C:  MOV     [--W15],W5
0054E:  RETURN  
.................... } 
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD. 
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR 
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device. 
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device.  
....................    unsigned int bFraming:1;   //A framing error has occurred. 
....................    unsigned int bParity:1;    //A parity error has occurred. 
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device. 
....................    unsigned int reserved0:1;   //future use 
....................    unsigned int reserved1:8;   //future use 
.................... } cdc_serial_state_t; 
....................  
.................... /* 
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring,  
....................    break signal and more (see cdc_serial_state_t). 
....................    Some of these values are held by the host (meaning it's value only needs 
....................    to be sent on change), but some values are one shot (meaning you continously 
....................    need to send value to host while being held). 
.................... */ 
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state) 
.................... { 
....................   #if __USB_PIC_PERIF__ 
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer 
....................   #else 
....................    unsigned int8 payload[10]; 
....................    #define CDC_EP1_NOTIFY_BUFFER payload 
....................   #endif 
....................  
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT)) 
....................       return(FALSE); 
....................  
....................    //bmRequestType 
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001 
....................    //bNotification 
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE 
....................    //wValue 
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0; 
....................    //wIndex 
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0; 
....................    //wLength 
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t) 
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0; 
....................    //data 
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state; 
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8; 
....................  
....................   #if __USB_PIC_PERIF__ 
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE); 
....................   #else 
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE); 
....................   #endif 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
*
0106C:  BCLR.B  1008.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
0106E:  MOV     4218,W0
01070:  MOV.B   #2,W0L
01072:  MOV     W0,4218
01074:  MOV     4218,W0
01076:  SWAP    W0
01078:  MOV.B   #2,W0L
0107A:  SWAP    W0
0107C:  MOV     W0,4218
0107E:  CALL    E2E
01082:  RETURN  
.................... } 
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit())  
....................    { 
....................      #if defined(USB_ISR_POLLING) 
....................       usb_task(); 
....................      #endif 
....................    } 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
....................    { 
....................       usb_cdc_get_discard(); 
....................    } 
....................  
....................    return(c); 
.................... } 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... #define __USB_PAUSE_ISR() 
.................... #define __USB_RESTORE_ISR() 
.................... #else 
.................... #define __USB_PAUSE_ISR()  int1 old_usbie; old_usbie = USBIE; USBIE = 0 
.................... #define __USB_RESTORE_ISR() if (old_usbie) USBIE = 1 
.................... #endif 
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................    __USB_PAUSE_ISR(); 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer))  
....................    { 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
....................    } 
....................     
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
....................  
....................    __USB_RESTORE_ISR(); 
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c) 
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
....................  
....................   #if defined(USB_ISR_POLLING) 
....................    // if interrupts are disabled, we should clear all activity isrs 
....................    // before we attempt to put any data onto an endpoint. 
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) 
....................       return; 
....................    usb_task(); 
....................   #endif 
....................    
....................   #if !defined(USB_CDC_DELAYED_FLUSH) 
....................    //if (usb_cdc_put_buffer_free())  
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_tx_buffer(); 
....................    } 
....................   #endif 
....................  
....................    //putc('*'); 
.................... } 
....................  
.................... void usb_cdc_putc(char c) 
.................... { 
....................    while (!usb_cdc_putready())  
....................    { 
....................      #if 1 
....................       if (usb_cdc_put_buffer_free())  
....................       { 
....................          usb_cdc_flush_tx_buffer(); 
....................       } 
....................      #endif 
....................  
....................      #if defined(USB_ISR_POLLING) 
....................       usb_task(); 
....................      #endif 
....................    } 
....................    usb_cdc_putc_fast(c); 
.................... } 
....................  
.................... int1 usb_cdc_putd(unsigned char *ptr, unsigned int8 len) 
.................... { 
....................  #if USB_EP2_TX_SIZE>=0x100 
....................    unsigned int16 i; 
....................  #else 
....................    unsigned int8 i; 
....................  #endif 
....................    char c; 
....................     
....................    i = 0; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    while(len--) 
....................    { 
....................       c = *ptr++; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_tx_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... {    
....................    unsigned int8 len; 
....................  
....................    len = strlen(ptr); 
....................    
....................    return(usb_cdc_putd(ptr, len)); 
.................... } 
....................  
.................... #endif //__USB_CDC_HELPERS_ONLY__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... char gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... char gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define SS      PIN_D7  //4 
.................... #define SCK     PIN_D4  //1 
.................... #define SDI     PIN_D3  //2 
.................... #define SDO     PIN_D5  //3 
.................... #define RESET   PIN_D1  //8 
.................... #define PWD     PIN_D2  //6 
.................... #define DRDY    PIN_D6  //5 
....................  
.................... #define USB_IDLE    0 
.................... #define USB_SENDING 1 
.................... #define USB_READING 2 
.................... #define USB_HEADER_SENDING 4 
.................... #define USB_DATA_IN_INPUT_BUFFER    3 
.................... #define USB_MAX_TRANSFER    63 
.................... #define USB_INPUT_BUFFER_SIZE   USB_MAX_TRANSFER 
.................... #define USB_MESSAGE_HEADER_SIZE 4 
.................... #define BUFFER_SIZE 8192 
.................... #define FILTER_ORDER 497 
.................... #define ASM_FILTER_ORDER #FILTER_ORDER 
....................  
.................... #pin_select SCK1OUT=SCK 
.................... #pin_select SDI1=SDI 
.................... #pin_select SDO1=SDO 
.................... #use SPI(MASTER,MODE=3, BITS=16, BAUD=3500000,SPI1, FORCE_HW, XFER16,STREAM=ADAS1) 
....................  
.................... #define SIMULATOR 
.................... //#define ALL_CHANNEL 
....................  
.................... #ifdef SIMULATOR 
.................... //#include <math.h> 
.................... #endif 
....................  
.................... uint8 UsbState=0; 
.................... uint8 UsbInputBuffer[USB_INPUT_BUFFER_SIZE]; 
.................... uint16 BufferReadPosition=0; 
.................... uint16 BufferIterator=0; 
.................... uint16 BufferElementAmount=0; 
.................... uint16 SavedBufferElementAmount=0; 
.................... uint16 BufferReadCounter=0; 
....................  
.................... sint32 FilterBufferCh11[FILTER_ORDER]; 
.................... sint32 FilterBufferCh12[FILTER_ORDER]; 
.................... //sint32 FilterBufferCh13[FILTER_ORDER]; 
.................... //sint32 FilterBufferCh14[FILTER_ORDER]; 
.................... //sint32 FilterBufferCh15[FILTER_ORDER]; 
.................... #banky //This preprocessor instruction ensure that the following data will be pressed into the Y Ram space. 
.................... uint16 Weight[FILTER_ORDER]= 
.................... { 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFC, 
.................... 0xFFFC, 
.................... 0xFFFC, 
.................... 0xFFFC, 
.................... 0xFFFD, 
.................... 0xFFFD, 
.................... 0xFFFD, 
.................... 0xFFFD, 
.................... 0xFFFE, 
.................... 0xFFFE, 
.................... 0xFFFE, 
.................... 0xFFFF, 
.................... 0xFFFF, 
.................... 0x0000, 
.................... 0x0000, 
.................... 0x0000, 
.................... 0x0001, 
.................... 0x0001, 
.................... 0x0002, 
.................... 0x0002, 
.................... 0x0003, 
.................... 0x0003, 
.................... 0x0004, 
.................... 0x0004, 
.................... 0x0005, 
.................... 0x0005, 
.................... 0x0006, 
.................... 0x0006, 
.................... 0x0007, 
.................... 0x0008, 
.................... 0x0008, 
.................... 0x0009, 
.................... 0x0009, 
.................... 0x000A, 
.................... 0x000B, 
.................... 0x000B, 
.................... 0x000C, 
.................... 0x000D, 
.................... 0x000E, 
.................... 0x000E, 
.................... 0x000F, 
.................... 0x0010, 
.................... 0x0011, 
.................... 0x0012, 
.................... 0x0012, 
.................... 0x0013, 
.................... 0x0014, 
.................... 0x0015, 
.................... 0x0016, 
.................... 0x0017, 
.................... 0x0018, 
.................... 0x0019, 
.................... 0x001A, 
.................... 0x001B, 
.................... 0x001C, 
.................... 0x001D, 
.................... 0x001E, 
.................... 0x001F, 
.................... 0x0020, 
.................... 0x0021, 
.................... 0x0022, 
.................... 0x0023, 
.................... 0x0024, 
.................... 0x0025, 
.................... 0x0026, 
.................... 0x0027, 
.................... 0x0028, 
.................... 0x002A, 
.................... 0x002B, 
.................... 0x002C, 
.................... 0x002D, 
.................... 0x002E, 
.................... 0x0030, 
.................... 0x0031, 
.................... 0x0032, 
.................... 0x0033, 
.................... 0x0035, 
.................... 0x0036, 
.................... 0x0037, 
.................... 0x0038, 
.................... 0x003A, 
.................... 0x003B, 
.................... 0x003C, 
.................... 0x003E, 
.................... 0x003F, 
.................... 0x0040, 
.................... 0x0042, 
.................... 0x0043, 
.................... 0x0044, 
.................... 0x0046, 
.................... 0x0047, 
.................... 0x0049, 
.................... 0x004A, 
.................... 0x004B, 
.................... 0x004D, 
.................... 0x004E, 
.................... 0x0050, 
.................... 0x0051, 
.................... 0x0052, 
.................... 0x0054, 
.................... 0x0055, 
.................... 0x0057, 
.................... 0x0058, 
.................... 0x005A, 
.................... 0x005B, 
.................... 0x005C, 
.................... 0x005E, 
.................... 0x005F, 
.................... 0x0061, 
.................... 0x0062, 
.................... 0x0064, 
.................... 0x0065, 
.................... 0x0066, 
.................... 0x0068, 
.................... 0x0069, 
.................... 0x006B, 
.................... 0x006C, 
.................... 0x006E, 
.................... 0x006F, 
.................... 0x0070, 
.................... 0x0072, 
.................... 0x0073, 
.................... 0x0075, 
.................... 0x0076, 
.................... 0x0077, 
.................... 0x0079, 
.................... 0x007A, 
.................... 0x007C, 
.................... 0x007D, 
.................... 0x007E, 
.................... 0x0080, 
.................... 0x0081, 
.................... 0x0082, 
.................... 0x0083, 
.................... 0x0085, 
.................... 0x0086, 
.................... 0x0087, 
.................... 0x0089, 
.................... 0x008A, 
.................... 0x008B, 
.................... 0x008C, 
.................... 0x008D, 
.................... 0x008F, 
.................... 0x0090, 
.................... 0x0091, 
.................... 0x0092, 
.................... 0x0093, 
.................... 0x0094, 
.................... 0x0096, 
.................... 0x0097, 
.................... 0x0098, 
.................... 0x0099, 
.................... 0x009A, 
.................... 0x009B, 
.................... 0x009C, 
.................... 0x009D, 
.................... 0x009E, 
.................... 0x009F, 
.................... 0x00A0, 
.................... 0x00A0, 
.................... 0x00A1, 
.................... 0x00A2, 
.................... 0x00A3, 
.................... 0x00A4, 
.................... 0x00A5, 
.................... 0x00A5, 
.................... 0x00A6, 
.................... 0x00A7, 
.................... 0x00A8, 
.................... 0x00A8, 
.................... 0x00A9, 
.................... 0x00AA, 
.................... 0x00AA, 
.................... 0x00AB, 
.................... 0x00AB, 
.................... 0x00AC, 
.................... 0x00AC, 
.................... 0x00AD, 
.................... 0x00AD, 
.................... 0x00AE, 
.................... 0x00AE, 
.................... 0x00AF, 
.................... 0x00AF, 
.................... 0x00AF, 
.................... 0x00B0, 
.................... 0x00B0, 
.................... 0x00B0, 
.................... 0x00B0, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B2, 
.................... 0x00B2, 
.................... 0x00B2, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B1, 
.................... 0x00B0, 
.................... 0x00B0, 
.................... 0x00B0, 
.................... 0x00B0, 
.................... 0x00AF, 
.................... 0x00AF, 
.................... 0x00AF, 
.................... 0x00AE, 
.................... 0x00AE, 
.................... 0x00AD, 
.................... 0x00AD, 
.................... 0x00AC, 
.................... 0x00AC, 
.................... 0x00AB, 
.................... 0x00AB, 
.................... 0x00AA, 
.................... 0x00AA, 
.................... 0x00A9, 
.................... 0x00A8, 
.................... 0x00A8, 
.................... 0x00A7, 
.................... 0x00A6, 
.................... 0x00A5, 
.................... 0x00A5, 
.................... 0x00A4, 
.................... 0x00A3, 
.................... 0x00A2, 
.................... 0x00A1, 
.................... 0x00A0, 
.................... 0x00A0, 
.................... 0x009F, 
.................... 0x009E, 
.................... 0x009D, 
.................... 0x009C, 
.................... 0x009B, 
.................... 0x009A, 
.................... 0x0099, 
.................... 0x0098, 
.................... 0x0097, 
.................... 0x0096, 
.................... 0x0094, 
.................... 0x0093, 
.................... 0x0092, 
.................... 0x0091, 
.................... 0x0090, 
.................... 0x008F, 
.................... 0x008D, 
.................... 0x008C, 
.................... 0x008B, 
.................... 0x008A, 
.................... 0x0089, 
.................... 0x0087, 
.................... 0x0086, 
.................... 0x0085, 
.................... 0x0083, 
.................... 0x0082, 
.................... 0x0081, 
.................... 0x0080, 
.................... 0x007E, 
.................... 0x007D, 
.................... 0x007C, 
.................... 0x007A, 
.................... 0x0079, 
.................... 0x0077, 
.................... 0x0076, 
.................... 0x0075, 
.................... 0x0073, 
.................... 0x0072, 
.................... 0x0070, 
.................... 0x006F, 
.................... 0x006E, 
.................... 0x006C, 
.................... 0x006B, 
.................... 0x0069, 
.................... 0x0068, 
.................... 0x0066, 
.................... 0x0065, 
.................... 0x0064, 
.................... 0x0062, 
.................... 0x0061, 
.................... 0x005F, 
.................... 0x005E, 
.................... 0x005C, 
.................... 0x005B, 
.................... 0x005A, 
.................... 0x0058, 
.................... 0x0057, 
.................... 0x0055, 
.................... 0x0054, 
.................... 0x0052, 
.................... 0x0051, 
.................... 0x0050, 
.................... 0x004E, 
.................... 0x004D, 
.................... 0x004B, 
.................... 0x004A, 
.................... 0x0049, 
.................... 0x0047, 
.................... 0x0046, 
.................... 0x0044, 
.................... 0x0043, 
.................... 0x0042, 
.................... 0x0040, 
.................... 0x003F, 
.................... 0x003E, 
.................... 0x003C, 
.................... 0x003B, 
.................... 0x003A, 
.................... 0x0038, 
.................... 0x0037, 
.................... 0x0036, 
.................... 0x0035, 
.................... 0x0033, 
.................... 0x0032, 
.................... 0x0031, 
.................... 0x0030, 
.................... 0x002E, 
.................... 0x002D, 
.................... 0x002C, 
.................... 0x002B, 
.................... 0x002A, 
.................... 0x0028, 
.................... 0x0027, 
.................... 0x0026, 
.................... 0x0025, 
.................... 0x0024, 
.................... 0x0023, 
.................... 0x0022, 
.................... 0x0021, 
.................... 0x0020, 
.................... 0x001F, 
.................... 0x001E, 
.................... 0x001D, 
.................... 0x001C, 
.................... 0x001B, 
.................... 0x001A, 
.................... 0x0019, 
.................... 0x0018, 
.................... 0x0017, 
.................... 0x0016, 
.................... 0x0015, 
.................... 0x0014, 
.................... 0x0013, 
.................... 0x0012, 
.................... 0x0012, 
.................... 0x0011, 
.................... 0x0010, 
.................... 0x000F, 
.................... 0x000E, 
.................... 0x000E, 
.................... 0x000D, 
.................... 0x000C, 
.................... 0x000B, 
.................... 0x000B, 
.................... 0x000A, 
.................... 0x0009, 
.................... 0x0009, 
.................... 0x0008, 
.................... 0x0008, 
.................... 0x0007, 
.................... 0x0006, 
.................... 0x0006, 
.................... 0x0005, 
.................... 0x0005, 
.................... 0x0004, 
.................... 0x0004, 
.................... 0x0003, 
.................... 0x0003, 
.................... 0x0002, 
.................... 0x0002, 
.................... 0x0001, 
.................... 0x0001, 
.................... 0x0000, 
.................... 0x0000, 
.................... 0x0000, 
.................... 0xFFFF, 
.................... 0xFFFF, 
.................... 0xFFFE, 
.................... 0xFFFE, 
.................... 0xFFFE, 
.................... 0xFFFD, 
.................... 0xFFFD, 
.................... 0xFFFD, 
.................... 0xFFFD, 
.................... 0xFFFC, 
.................... 0xFFFC, 
.................... 0xFFFC, 
.................... 0xFFFC, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFB, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFF9, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFA, 
.................... 0xFFFB, 
.................... 0xFFFB 
.................... }; 
.................... struct 
.................... { 
....................     struct 
....................     { 
....................         uint8 Start; 
....................         uint8 Sign; 
....................         uint8 Size1; 
....................         uint8 Size2; 
....................     } Header; 
....................     union 
....................     { 
....................         uint8 Bytes[BUFFER_SIZE]; 
....................         uint32 Data[BUFFER_SIZE/4]; 
....................     } Data; 
.................... }Message; 
....................  
.................... /* This function changes the endianness in double-words. */ 
.................... uint32 ChangeEndiannes32Bit(uint32 Data) 
.................... { 
.................... #asm 
....................     MOV Data, W1 
*
0147E:  MOV     4206,W1
....................     MOV Data+2, W2 
01480:  MOV     4208,W2
....................     SWAP W1 
01482:  SWAP    W1
....................     SWAP W2 
01484:  SWAP    W2
....................     EXCH W1, W2 
01486:  EXCH    W2,W1
....................     MOV W2, Data+2 
01488:  MOV     W2,4208
....................     MOV W1,Data 
0148A:  MOV     W1,4206
.................... #endasm 
....................     return Data; 
0148C:  MOV     4206,W0
0148E:  MOV     4208,W1
01490:  RETURN  
.................... } 
....................  
.................... void ruUsb() 
.................... { 
....................     uint16 looper=0; 
....................     switch(UsbState) 
....................     { 
....................         case USB_DATA_IN_INPUT_BUFFER: 
....................         case USB_IDLE: 
....................             if(usb_cdc_kbhit()) 
....................             { 
....................                 UsbState=USB_READING; 
....................             } 
....................             break; 
....................         case USB_HEADER_SENDING: 
....................             if(usb_cdc_put_buffer_free()) 
....................             { 
....................                 BufferReadPosition = (0x7FF & (BufferIterator-BufferElementAmount))*4; 
....................                 SavedBufferElementAmount=BufferElementAmount; 
....................                 BufferElementAmount=0; 
....................                 Message.Header.Size1=SavedBufferElementAmount*4>>8; 
....................                 Message.Header.Size2=SavedBufferElementAmount*4; 
....................                 _usb_cdc_putc_fast_noflush(Message.Header.Start); 
....................                 _usb_cdc_putc_fast_noflush(Message.Header.Sign); 
....................                 _usb_cdc_putc_fast_noflush(Message.Header.Size1); 
....................                 _usb_cdc_putc_fast_noflush(Message.Header.Size2); 
....................                 UsbState=USB_SENDING; 
....................                 looper=4; 
....................             } 
....................             else 
....................             { 
....................                 break; 
....................             } 
....................         case USB_SENDING: 
....................             if(usb_cdc_put_buffer_free()) 
....................             { 
....................                 while((looper<USB_MAX_TRANSFER) && (BufferReadCounter < (SavedBufferElementAmount*4))) 
....................                 { 
....................                     _usb_cdc_putc_fast_noflush(Message.Data.Bytes[BufferReadPosition]); 
....................                     BufferReadPosition++; 
....................                     looper++; 
....................                     BufferReadCounter++; 
....................                     if(BufferReadPosition == BUFFER_SIZE) BufferReadPosition = 0;  
....................                 } 
....................                 usb_cdc_flush_tx_buffer(); 
....................                 if(BufferReadCounter == (SavedBufferElementAmount*4)) 
....................                 { 
....................                     BufferReadCounter=0; 
....................                     UsbState=USB_IDLE; 
....................                 } 
....................             } 
....................             break; 
....................         case USB_READING: 
....................             while(looper<USB_MAX_TRANSFER && usb_cdc_kbhit()) 
....................             { 
....................                 UsbInputBuffer[looper]=usb_cdc_getc(); 
....................                 looper++; 
....................             } 
....................             if(!usb_cdc_kbhit()) 
....................             { 
....................                 UsbState=USB_DATA_IN_INPUT_BUFFER; 
....................                  
....................             } 
....................             break; 
....................     } 
.................... } 
.................... void ruUsbInputProcess(void) 
.................... { 
....................     if(UsbState == USB_DATA_IN_INPUT_BUFFER) 
....................     { 
....................         if(UsbInputBuffer[0] == 'S') 
....................         { 
....................             switch(UsbInputBuffer[1]) 
....................             { 
....................                 case 1: 
....................                     UsbState=USB_HEADER_SENDING; 
....................                     output_toggle(PIN_B1); 
....................                     break; 
....................                 case 2: 
....................                      
....................                     break; 
....................             } 
....................         } 
....................     } 
....................      
.................... } 
....................  
.................... int32 AdasSpiReadWrite(int32 command) 
.................... { 
....................     int32 ret=0; 
....................     output_low(SS); //Slave select láb szoftveresen vezérelve 
....................     ret = (spi_xfer(ADAS1,command>>16))<<16; 
....................     ret += spi_xfer(ADAS1,(int16)command); 
....................     if((ret>>24) == 0xf) printf(usb_cdc_putc,"1.\n");//debug jelzés 
....................     output_high(SS);//Slave select láb szoftveresen vezérelve 
....................     return (ret); 
.................... } 
....................  
.................... /* This function implements the initialization of the ADAS1000 front-end IC via SPI */ 
.................... void AdasInit() 
.................... { 
....................     output_high(PWD); 
....................     output_high(RESET); 
....................     delay_ms(20); 
....................     unsigned char looper; 
....................     long answer=0; 
....................     long conf[5] = 
....................                     { 
....................                         0x0A07FF00,//Frame control register 
....................                         0x05E00003,//Common mode register 
....................                         0x08800005,//Test tone register: utolsó bájt: 15: négyszög; 05: 10Hz szinusz 
....................                         0x0B000000,//Filter control register: a defaul megfelel? 
....................                         0x01F804AE//ECG control register analog lead mode 
....................                         //0x01F800AE//ECG control register digital lead mode 
....................                     }; 
....................     for(looper=0;looper<3;looper++) 
....................     { 
....................         AdasSpiReadWrite(conf[0]|0x80000000); 
....................         AdasSpiReadWrite(conf[0]); 
....................         answer=AdasSpiReadWrite(conf[1]|0x80000000); 
....................         AdasSpiReadWrite(conf[1]); 
....................         answer=AdasSpiReadWrite(conf[2]|0x80000000); 
....................         AdasSpiReadWrite(conf[2]); 
....................         answer=AdasSpiReadWrite(conf[3]|0x80000000); 
....................         AdasSpiReadWrite(conf[3]); 
....................         answer=AdasSpiReadWrite(conf[4]|0x80000000); 
....................         AdasSpiReadWrite(conf[4]);// 
....................         answer=AdasSpiReadWrite(0); 
....................     } 
....................     AdasSpiReadWrite(0x40000000);//*/ 
.................... } 
.................... uint32 TracerVariable; 
.................... uint32 FirWeighter(uint32 RawData) 
.................... { 
....................     uint32 ret;//=FirFilterBuffer[248]; 
....................     uint16 Address; 
.................... #asm 
....................     /* Save the working registers in to the stack. */ 
....................     PUSH W1; 
*
01600:  MOV     W1,[W15++]
....................     PUSH W3; 
01602:  MOV     W3,[W15++]
....................     PUSH W4; 
01604:  MOV     W4,[W15++]
....................     PUSH W5; 
01606:  MOV     W5,[W15++]
....................     PUSH W8; 
01608:  MOV     W8,[W15++]
....................     PUSH W10; 
0160A:  MOV     W10,[W15++]
....................     PUSH W2 
0160C:  MOV     W2,[W15++]
....................     PUSH W0 
0160E:  MOV     W0,[W15++]
....................      
....................     /*This part of code cuts the address from the data and shifts it right with 5.*/ 
....................     MOV RawData+2, W1 
01610:  MOV     4202,W1
....................     MOV W1,(Address) 
01612:  MOV     W1,4208
....................     MOV #0x00ff, W3 
01614:  MOV     #FF,W3
....................     AND W1,W3,W1 
01616:  AND     W1,W3,W1
....................     AND W1,#0x1F,W3 
01618:  AND     W1,#1F,W3
....................     LSR W1, #5, W1 
0161A:  LSR     W1,#5,W1
....................     SL W3,#11,W3 
0161C:  SL      W3,#B,W3
....................     MOV W1, RawData+2 
0161E:  MOV     W1,4202
....................     MOV W1, ret+2//TODO 
01620:  MOV     W1,4206
....................     MOV RawData, W1 
01622:  MOV     4200,W1
....................     LSR W1,#5,W1 
01624:  LSR     W1,#5,W1
....................     IOR W1,W3,W1 
01626:  IOR      W1,  W3,W1
....................     MOV W1, RawData 
01628:  MOV     W1,4200
....................     MOV W1, ret//TODO: 
0162A:  MOV     W1,4204
....................     MOV #0xff00, W0 
0162C:  MOV     #FF00,W0
....................     AND Address 
0162E:  MOV     4208,W4
01630:  AND     8
01632:  MOV     W4,4208
....................      
....................     /* Set up the size of the filter order to loop */ 
....................     MOV ASM_FILTER_ORDER,W1 
01634:  MOV     #1F1,W1
....................     DEC W1,W1 
01636:  DEC     W1,W1
....................     SL W1,#2,W1 
01638:  SL      W1,#2,W1
....................      
....................     /* Set W8 to point to the last word of the buffer array. */ 
....................     MOV Address, W2 
0163A:  MOV     4208,W2
....................     MOV #0x1100, W3 
0163C:  MOV     #1100,W3
....................     MOV #0x1200,W4 
0163E:  MOV     #1200,W4
....................     MOV #0x1300,W5 
01640:  MOV     #1300,W5
....................     MOV #0x1400,W10 
01642:  MOV     #1400,W10
....................     MOV #0x1500,W0 
01644:  MOV     #1500,W0
....................     CPSNE W2,W3 
01646:  CPSNE   W2,W3
....................     MOV (FilterBufferCh11), W8  //W8 contains the BaseAddress 
01648:  MOV     #1260,W8
....................     CPSNE W2,W4 
0164A:  CPSNE   W2,W4
....................     MOV (FilterBufferCh12), W8  //W8 contains the BaseAddress 
0164C:  MOV     #1A24,W8
....................     CPSNE W2,W5 
0164E:  CPSNE   W2,W5
....................     MOV (FilterBufferCh12), W8  //W8 contains the BaseAddress 
01650:  MOV     #1A24,W8
....................     CPSNE W2,W10 
01652:  CPSNE   W2,W10
....................     MOV (FilterBufferCh11), W8  //W8 contains the BaseAddress 
01654:  MOV     #1260,W8
....................     CPSNE W2,W0 
01656:  CPSNE   W2,W0
....................     MOV (FilterBufferCh11), W8  //W8 contains the BaseAddress 
01658:  MOV     #1260,W8
....................     ADD W8,W1,W8 
0165A:  ADD     W8,W1,W8
....................     ADD W8, #2,W8 
0165C:  ADD     W8,#2,W8
....................  
....................     /* Set the W10 register to the last element of the weight array. */ 
....................     MOV (&Weight),W10 
0165E:  MOV     #5000,W10
....................     LSR W1,W3 
01660:  LSR     W1,W3
....................     ADD W10,W3,W10 
01662:  ADD     W10,W3,W10
....................      
....................     /* Clear the accumulators */ 
....................     CLR A 
01664:  CLR     A
....................     CLR B 
01666:  CLR     
....................      
....................     /* Set the elements into the W3 and W4 and step away the W8 and W10 pointers. */ 
....................     MOV [W8--], W4 
01668:  MOV     [W8--],W4
....................     MOV [W10--], W5 
0166A:  MOV     [W10--],W5
....................  
....................     /* This is a cycle that loop till the first element. In this cycle the buffer will be multiplied by the weight 
....................      * the high word in the accumulator A and the low word in the accumulator B. During this the elements of the   
....................      * buffer will be shifted away. */ 
....................     MOV #4,W3 
0166C:  MOV     #4,W3
....................     LSR W1,#2,W1 
0166E:  LSR     W1,#2,W1
....................     DEC W1,W1 
01670:  DEC     W1,W1
....................     DO W1,loop 
01672:  DO      W1,167C
....................         MAC W4*W5, A, [W8]-=2, W4 
01676:  MAC     W4*W5,A, [W8]-=2,W4
....................         MOV [W8], [W8+W3] 
01678:  MOV     [W8],[W8+W3]
....................         MAC W4*W5, B, [W8]-=2, W4, [W10]-=2, W5 
0167A:  MAC     W4*W5,, [W8]-=2,W4, [W10]-=2,W5
....................         loop: 
....................         MOV [W8], [W8+W3] 
0167C:  MOV     [W8],[W8+W3]
....................          
....................     /* Load the most fresh data in the front of the buffer. After that this will be multiplied too. */ 
....................     MOV (&RawData), W3 
0167E:  MOV     #4200,W3
....................     MOV [W3++], [W8++] 
01680:  MOV     [W3++],[W8++]
....................     MOV [W3], [W8--] 
01682:  MOV     [W3],[W8--]
....................     MOV [W3--], W4; 
01684:  MOV     [W3--],W4
....................     MAC W4*W5, A, [W8], W4; 
01686:  MAC     W4*W5,A, [W8],W4
....................     MAC W4*W5, B 
01688:  MAC     W4*W5,
....................              
....................     /* The higher and the lower part of the output data will be merged. */ 
....................     SFTAC A,#-1 
0168A:  SFTAC   A,#FFFFFFE1
....................     SFTAC B,#15 
0168C:  SFTAC   B,#F
....................     ADD A 
0168E:  ADD     A
....................              
....................     /* The accumulator read out and save into the RawData variable. */ 
....................     SAC A,#0,[++W3] 
01690:  SAC     A,[++W3]
....................     SFTAC A, #-16 
01692:  SFTAC   A,#10
....................     SAC A,#0,[--W3] 
01694:  SAC     A,[--W3]
....................      
....................     /* Load the working registers back from the stack. */ 
....................     POP W0 
01696:  MOV     [--W15],W0
....................     POP W2 
01698:  MOV     [--W15],W2
....................     POP W10 
0169A:  MOV     [--W15],W10
....................     POP W8 
0169C:  MOV     [--W15],W8
....................     POP W5 
0169E:  MOV     [--W15],W5
....................     POP W4 
016A0:  MOV     [--W15],W4
....................     POP W3 
016A2:  MOV     [--W15],W3
....................     POP W1 
016A4:  MOV     [--W15],W1
.................... #endasm 
....................     ret=(ret-RawData); 
016A6:  MOV     4204,W0
016A8:  MOV     4200,W4
016AA:  SUB     W0,W4,W0
016AC:  MOV     W0,4204
016AE:  MOV     4206,W0
016B0:  MOV     4202,W4
016B2:  SUBB    W0,W4,W0
016B4:  MOV     W0,4206
.................... #asm 
....................     MOV #0x00ff, W0 
016B6:  MOV     #FF,W0
....................     AND ret+2 
016B8:  MOV     4206,W4
016BA:  AND     8
016BC:  MOV     W4,4206
....................     MOV Address,W0 
016BE:  MOV     4208,W4
016C0:  MOV     8,W0
016C2:  MOV     W4,4208
....................     IOR ret+2 
016C4:  MOV     4206,W4
016C6:  IOR     8
016C8:  MOV     W4,4206
.................... #endasm 
....................     return ret; 
016CA:  MOV     4204,W0
016CC:  MOV     4206,W1
016CE:  RETURN  
.................... } 
.................... uint32 globalvar=0; 
.................... void ruAdasHandler(void) 
016D0:  MOV     W5,[W15++]
016D2:  MOV     W6,[W15++]
016D4:  MOV     W7,[W15++]
.................... { 
.................... #ifndef SIMULATOR 
....................     if(0 == input(DRDY)) 
.................... #endif 
....................     { 
....................         //output_toggle(PIN_B0); 
....................         uint16 looper; 
....................         uint32 Temporary=0x11000000; 
016D6:  MOV     #0,W4
016D8:  MOV     W4,41F8
016DA:  MOV     #1100,W4
016DC:  MOV     W4,41FA
....................         for(looper = 0; looper<6; looper++, BufferIterator++) 
016DE:  MOV     #0,W4
016E0:  MOV     W4,41F6
016E2:  MOV     41F6,W0
016E4:  CP      W0,#6
016E6:  BRA     C,17A0
....................         { 
.................... #ifndef SIMULATOR 
....................             Temporary = AdasSpiReadWrite(0x00000000); 
.................... #endif 
....................  
.................... #ifndef ALL_CHANNEL 
....................             if(((Temporary&0xFF000000)>>24) != 0x11) 
016E8:  MOV     41F8,W0
016EA:  CLR     W5
016EC:  MOV     41FA,W4
016EE:  MOV     #FF00,W0
016F0:  AND     W0,W4,W6
016F2:  MOV.B   D,W0L
016F4:  MOV.B   W0L,W5L
016F6:  CLR.B   B
016F8:  CLR.B   W6
016FA:  CLR.B   D
016FC:  CP      W5,#11
016FE:  BRA     NZ,1704
01700:  CP0     W6
01702:  BRA     Z,1732
....................             { 
....................                 Message.Data.Data[BufferIterator] = ChangeEndiannes32Bit(Temporary); 
01704:  MOV     11B2,W0
01706:  SL      W0,#2,W0
01708:  MOV     #21EC,W4
0170A:  ADD     W0,W4,W5
0170C:  PUSH    41F8
0170E:  POP     4206
01710:  PUSH    41FA
01712:  POP     4208
01714:  CALL    147E
01718:  MOV     #0,W4
0171A:  MOV     [W4++],[W5++]
0171C:  MOV     [W4++],[W5++]
....................                 Temporary++; 
0171E:  MOV     41F8,W0
01720:  MOV     41FA,W1
01722:  INC     W0,W0
01724:  MOV     W0,41F8
01726:  MOV     41FA,W0
01728:  BTSC.B  42.1
0172A:  INC     W0,W0
0172C:  MOV     W0,41FA
....................             } 
0172E:  GOTO    1786
....................             else 
....................             { 
....................                 output_high(PIN_B0); 
01732:  BCLR.B  E10.0
01734:  BSET.B  E14.0
.................... #ifdef SIMULATOR 
....................                 Temporary |= 0x7ffff; 
01736:  MOV     41F8,W0
01738:  MOV     W0,W4
0173A:  MOV     #FFFF,W0
0173C:  IOR      W0,  W4,W0
0173E:  MOV     W0,41F8
01740:  MOV     41FA,W0
01742:  IOR      W0,  #7,W0
01744:  MOV     W0,41FA
....................                 //Temporary = 1000+1000*32*sin(2*PI/200*globalvar); 
....................                 if(globalvar == 200) globalvar=0; 
01746:  MOV     11BE,W4
01748:  XOR     #C8,W4
0174A:  BRA     NZ,1758
0174C:  CP0     11C0
0174E:  BRA     NZ,1758
01750:  CLR     11BE
01752:  CLR     11C0
01754:  GOTO    175E
....................                 else globalvar++; 
01758:  INC     11BE
0175A:  BTSC.B  42.1
0175C:  INC     11C0
....................                 Message.Data.Data[BufferIterator] = ChangeEndiannes32Bit(FirWeighter(Temporary)); 
0175E:  MOV     11B2,W0
01760:  SL      W0,#2,W0
01762:  MOV     #21EC,W4
01764:  ADD     W0,W4,W5
01766:  PUSH    41F8
01768:  POP     4200
0176A:  PUSH    41FA
0176C:  POP     4202
0176E:  CALL    1600
01772:  MOV.D   W0,W6
01774:  MOV     W6,4206
01776:  MOV     W7,4208
01778:  CALL    147E
0177C:  MOV     #0,W4
0177E:  MOV     [W4++],[W5++]
01780:  MOV     [W4++],[W5++]
.................... #else 
....................                 Message.Data.Data[BufferIterator] = ChangeEndiannes32Bit(FirWeighter(Temporary)); 
.................... #endif 
....................                 output_low(PIN_B0); 
01782:  BCLR.B  E10.0
01784:  BCLR.B  E14.0
....................             } 
.................... #else 
....................             Message.Data.Data[BufferIterator] = ChangeEndiannes32Bit(FirWeighter(Temporary)); 
.................... #endif 
....................             //Message.Data.Data[BufferIterator] = ChangeEndiannes32Bit(AdasSpiReadWrite(0x00000000)); 
....................              
....................             if(BufferIterator == ((BUFFER_SIZE/4)-1)) 
01786:  MOV     11B2,W4
01788:  MOV     #7FF,W3
0178A:  CP      W3,W4
0178C:  BRA     NZ,1790
....................             { 
....................                 BufferIterator = -1; 
0178E:  SETM    11B2
....................             } 
01790:  MOV     41F6,W0
01792:  MOV     W0,[W15++]
01794:  INC     W0,W0
01796:  MOV     W0,41F6
01798:  MOV     [--W15],W0
0179A:  INC     11B2
0179C:  GOTO    16E2
....................         } 
....................         BufferElementAmount+=6; 
017A0:  MOV     11B4,W4
017A2:  ADD     W4,#6,W0
017A4:  MOV     W0,11B4
....................         if(BufferElementAmount >(BUFFER_SIZE/4)) BufferElementAmount=(BUFFER_SIZE/4); 
017A6:  MOV     11B4,W4
017A8:  MOV     #800,W3
017AA:  CP      W3,W4
017AC:  BRA     C,17B2
017AE:  MOV     #800,W4
017B0:  MOV     W4,11B4
....................     } 
017B2:  MOV     [--W15],W7
017B4:  MOV     [--W15],W6
017B6:  MOV     [--W15],W5
017B8:  RETURN  
.................... } 
....................  
.................... void ruBufferTester(void) 
*
01492:  MOV     W5,[W15++]
01494:  MOV     W6,[W15++]
01496:  MOV     W7,[W15++]
.................... { 
....................     unsigned long looper; 
....................     unsigned long looper2; 
....................     for(looper=0,looper2=0;looper<BUFFER_SIZE/4;looper++, looper2++,BufferIterator++,BufferElementAmount++) 
01498:  MOV     #0,W4
0149A:  MOV     W4,41F6
0149C:  MOV     #0,W4
0149E:  MOV     W4,41F8
014A0:  MOV     #0,W4
014A2:  MOV     W4,41FA
014A4:  MOV     #0,W4
014A6:  MOV     W4,41FC
014A8:  MOV     41F8,W0
014AA:  CP      W0,#0
014AC:  BRA     GTU,15F8
014AE:  BRA     NC,14B8
014B0:  MOV     41F6,W0
014B2:  MOV     #800,W4
014B4:  CP      W4,W0
014B6:  BRA     LEU,15F8
....................     { 
....................         switch(looper2) 
014B8:  MOV     41FA,W0
014BA:  MOV     41FC,W1
014BC:  CP0     W0
014BE:  BRA     NZ,14C4
014C0:  CP0     W1
014C2:  BRA     Z,14E6
014C4:  CP      W0,#1
014C6:  BRA     NZ,14CC
014C8:  CP0     W1
014CA:  BRA     Z,150A
014CC:  CP      W0,#2
014CE:  BRA     NZ,14D4
014D0:  CP0     W1
014D2:  BRA     Z,152E
014D4:  CP      W0,#3
014D6:  BRA     NZ,14DC
014D8:  CP0     W1
014DA:  BRA     Z,1552
014DC:  CP      W0,#4
014DE:  BRA     NZ,14E4
014E0:  CP0     W1
014E2:  BRA     Z,1576
014E4:  BRA     15A2
....................         { 
....................             case 0: 
....................                 Message.Data.Data[BufferIterator]=ChangeEndiannes32Bit(0x11000000|looper); 
014E6:  MOV     11B2,W0
014E8:  SL      W0,#2,W0
014EA:  MOV     #21EC,W4
014EC:  ADD     W0,W4,W5
014EE:  MOV     41F6,W0
014F0:  MOV     W0,W6
014F2:  MOV     41F8,W4
014F4:  MOV     #1100,W0
014F6:  IOR      W0,  W4,W7
014F8:  MOV     W6,4206
014FA:  MOV     W7,4208
014FC:  CALL    147E
01500:  MOV     #0,W4
01502:  MOV     [W4++],[W5++]
01504:  MOV     [W4++],[W5++]
....................                 break; 
01506:  GOTO    15AA
....................             case 1: 
....................                 Message.Data.Data[BufferIterator]=ChangeEndiannes32Bit(0x12000000|looper); 
0150A:  MOV     11B2,W0
0150C:  SL      W0,#2,W0
0150E:  MOV     #21EC,W4
01510:  ADD     W0,W4,W5
01512:  MOV     41F6,W0
01514:  MOV     W0,W6
01516:  MOV     41F8,W4
01518:  MOV     #1200,W0
0151A:  IOR      W0,  W4,W7
0151C:  MOV     W6,4206
0151E:  MOV     W7,4208
01520:  CALL    147E
01524:  MOV     #0,W4
01526:  MOV     [W4++],[W5++]
01528:  MOV     [W4++],[W5++]
....................                 break; 
0152A:  GOTO    15AA
....................             case 2: 
....................                 Message.Data.Data[BufferIterator]=ChangeEndiannes32Bit(0x13000000|looper); 
0152E:  MOV     11B2,W0
01530:  SL      W0,#2,W0
01532:  MOV     #21EC,W4
01534:  ADD     W0,W4,W5
01536:  MOV     41F6,W0
01538:  MOV     W0,W6
0153A:  MOV     41F8,W4
0153C:  MOV     #1300,W0
0153E:  IOR      W0,  W4,W7
01540:  MOV     W6,4206
01542:  MOV     W7,4208
01544:  CALL    147E
01548:  MOV     #0,W4
0154A:  MOV     [W4++],[W5++]
0154C:  MOV     [W4++],[W5++]
....................                 break; 
0154E:  GOTO    15AA
....................             case 3: 
....................                 Message.Data.Data[BufferIterator]=ChangeEndiannes32Bit(0x14000000|looper); 
01552:  MOV     11B2,W0
01554:  SL      W0,#2,W0
01556:  MOV     #21EC,W4
01558:  ADD     W0,W4,W5
0155A:  MOV     41F6,W0
0155C:  MOV     W0,W6
0155E:  MOV     41F8,W4
01560:  MOV     #1400,W0
01562:  IOR      W0,  W4,W7
01564:  MOV     W6,4206
01566:  MOV     W7,4208
01568:  CALL    147E
0156C:  MOV     #0,W4
0156E:  MOV     [W4++],[W5++]
01570:  MOV     [W4++],[W5++]
....................                 break; 
01572:  GOTO    15AA
....................             case 4: 
....................                 Message.Data.Data[BufferIterator]=ChangeEndiannes32Bit(0x15000000|looper); 
01576:  MOV     11B2,W0
01578:  SL      W0,#2,W0
0157A:  MOV     #21EC,W4
0157C:  ADD     W0,W4,W5
0157E:  MOV     41F6,W0
01580:  MOV     W0,W6
01582:  MOV     41F8,W4
01584:  MOV     #1500,W0
01586:  IOR      W0,  W4,W7
01588:  MOV     W6,4206
0158A:  MOV     W7,4208
0158C:  CALL    147E
01590:  MOV     #0,W4
01592:  MOV     [W4++],[W5++]
01594:  MOV     [W4++],[W5++]
....................                 looper2=-1; 
01596:  MOV     #FFFF,W0
01598:  MOV     #FFFF,W1
0159A:  MOV     W0,41FA
0159C:  MOV     W1,41FC
....................                 break; 
0159E:  GOTO    15AA
....................             default: 
....................                 looper2=-1; 
015A2:  MOV     #FFFF,W0
015A4:  MOV     #FFFF,W1
015A6:  MOV     W0,41FA
015A8:  MOV     W1,41FC
....................         } 
....................         if(BufferIterator == ((BUFFER_SIZE/4)-1)) 
015AA:  MOV     11B2,W4
015AC:  MOV     #7FF,W3
015AE:  CP      W3,W4
015B0:  BRA     NZ,15B4
....................         { 
....................             BufferIterator = -1; 
015B2:  SETM    11B2
....................         } 
....................         if(BufferElementAmount >(BUFFER_SIZE/4)) BufferElementAmount=(BUFFER_SIZE/4); 
015B4:  MOV     11B4,W4
015B6:  MOV     #800,W3
015B8:  CP      W3,W4
015BA:  BRA     C,15C0
015BC:  MOV     #800,W4
015BE:  MOV     W4,11B4
015C0:  MOV     41F6,W0
015C2:  MOV     W0,[W15++]
015C4:  MOV     W1,[W15++]
015C6:  INC     W0,W0
015C8:  MOV     W0,41F6
015CA:  MOV     41F8,W0
015CC:  BTSC.B  42.1
015CE:  INC     W0,W0
015D0:  MOV     W0,41F8
015D2:  MOV     [--W15],W1
015D4:  MOV     [--W15],W0
015D6:  MOV     41FA,W0
015D8:  MOV     41FC,W1
015DA:  MOV     W0,[W15++]
015DC:  MOV     W1,[W15++]
015DE:  INC     W0,W0
015E0:  MOV     W0,41FA
015E2:  MOV     41FC,W0
015E4:  BTSC.B  42.1
015E6:  INC     W0,W0
015E8:  MOV     W0,41FC
015EA:  MOV     [--W15],W1
015EC:  MOV     [--W15],W0
015EE:  MOV     11B2,W0
015F0:  INC     11B2
015F2:  INC     11B4
015F4:  GOTO    14A8
....................     } 
015F8:  MOV     [--W15],W7
015FA:  MOV     [--W15],W6
015FC:  MOV     [--W15],W5
015FE:  RETURN  
.................... } 
....................  
.................... int main()  
*
017BA:  MOV     #6F80,W15
017BC:  MOV     #6FFF,W0
017BE:  MOV     W0,20
017C0:  NOP     
017C2:  BSET.B  8C1.7
017C4:  DISI    #6
017C6:  MOV     #742,W1
017C8:  MOV     #46,W2
017CA:  MOV     #57,W3
017CC:  MOV.B   W2L,[W1]
017CE:  MOV.B   W3L,[W1]
017D0:  BCLR.B  742.6
017D2:  MOV     #4443,W0
017D4:  MOV     W0,6C8
017D6:  MOV     #506,W0
017D8:  MOV     W0,684
017DA:  DISI    #6
017DC:  MOV     #742,W1
017DE:  MOV     #46,W2
017E0:  MOV     #57,W3
017E2:  MOV.B   W2L,[W1]
017E4:  MOV.B   W3L,[W1]
017E6:  BSET.B  742.6
017E8:  MOV     #21,W4
017EA:  MOV     W4,746
017EC:  CLR     744
017EE:  DISI    #E
017F0:  MOV     #103,W0
017F2:  MOV     #743,W1
017F4:  MOV     #78,W2
017F6:  MOV     #9A,W3
017F8:  MOV.B   W2L,[W1]
017FA:  MOV.B   W3L,[W1]
017FC:  MOV.B   W0L,743
017FE:  LSR     W0,#8,W0
01800:  MOV     #742,W1
01802:  MOV     #46,W2
01804:  MOV     #57,W3
01806:  MOV.B   W2L,[W1]
01808:  MOV.B   W3L,[W1]
0180A:  MOV.B   W0L,[W1]
0180C:  MOV     #A4C2,W4
0180E:  MOV     W4,758
01810:  MOV     #3,W4
01812:  MOV     W4,75A
01814:  CLR.B   100B
01816:  BCLR.B  241.7
01818:  BCLR.B  E30.5
0181A:  BSET.B  E30.3
0181C:  BCLR.B  E30.4
0181E:  BCLR.B  240.6
01820:  MOV     #46E,W4
01822:  MOV     W4,242
01824:  BSET.B  241.7
01826:  CLR.B   116E
01828:  CLR     11B0
0182A:  CLR     11B2
0182C:  CLR     11B4
0182E:  CLR     11B6
01830:  CLR     11B8
01832:  CLR     11BE
01834:  CLR     11C0
01836:  CLR     E1E
01838:  CLR     E2E
0183A:  CLR     E3E
0183C:  CLR     E4E
0183E:  CLR     E6E
01840:  BRA     1AFA
01842:  DATA    80,02,11
01844:  DATA    6C,00,00
01846:  DATA    80,7D,50
01848:  DATA    00,FB,FF
0184A:  DATA    FB,FF,FA
0184C:  DATA    FF,FA,FF
0184E:  DATA    FA,FF,FA
01850:  DATA    FF,FA,FF
01852:  DATA    FA,FF,FA
01854:  DATA    FF,FA,FF
01856:  DATA    FA,FF,FA
01858:  DATA    FF,FA,FF
0185A:  DATA    F9,FF,F9
0185C:  DATA    FF,F9,FF
0185E:  DATA    F9,FF,F9
01860:  DATA    FF,F9,FF
01862:  DATA    F9,FF,F9
01864:  DATA    FF,F9,FF
01866:  DATA    F9,FF,F9
01868:  DATA    FF,F9,FF
0186A:  DATA    F9,FF,F9
0186C:  DATA    FF,F9,FF
0186E:  DATA    F9,FF,F9
01870:  DATA    FF,F9,FF
01872:  DATA    F9,FF,F9
01874:  DATA    FF,F9,FF
01876:  DATA    F9,FF,F9
01878:  DATA    FF,F9,FF
0187A:  DATA    F9,FF,F9
0187C:  DATA    FF,F9,FF
0187E:  DATA    FA,FF,FA
01880:  DATA    FF,FA,FF
01882:  DATA    FA,FF,FA
01884:  DATA    FF,FA,FF
01886:  DATA    FA,FF,FB
01888:  DATA    FF,FB,FF
0188A:  DATA    FB,FF,FB
0188C:  DATA    FF,FB,FF
0188E:  DATA    FC,FF,FC
01890:  DATA    FF,FC,FF
01892:  DATA    FC,FF,FD
01894:  DATA    FF,FD,FF
01896:  DATA    FD,FF,FD
01898:  DATA    FF,FE,FF
0189A:  DATA    FE,FF,FE
0189C:  DATA    40,05,FF
0189E:  DATA    40,06,00
018A0:  DATA    02,D1,01
018A2:  DATA    00,01,00
018A4:  DATA    02,00,02
018A6:  DATA    00,03,00
018A8:  DATA    03,00,04
018AA:  DATA    00,04,00
018AC:  DATA    05,00,05
018AE:  DATA    00,06,00
018B0:  DATA    06,00,07
018B2:  DATA    00,08,00
018B4:  DATA    08,00,09
018B6:  DATA    00,09,00
018B8:  DATA    0A,00,0B
018BA:  DATA    00,0B,00
018BC:  DATA    0C,00,0D
018BE:  DATA    00,0E,00
018C0:  DATA    0E,00,0F
018C2:  DATA    00,10,00
018C4:  DATA    11,00,12
018C6:  DATA    00,12,00
018C8:  DATA    13,00,14
018CA:  DATA    00,15,00
018CC:  DATA    16,00,17
018CE:  DATA    00,18,00
018D0:  DATA    19,00,1A
018D2:  DATA    00,1B,00
018D4:  DATA    1C,00,1D
018D6:  DATA    00,1E,00
018D8:  DATA    1F,00,20
018DA:  DATA    00,21,00
018DC:  DATA    22,00,23
018DE:  DATA    00,24,00
018E0:  DATA    25,00,26
018E2:  DATA    00,27,00
018E4:  DATA    28,00,2A
018E6:  DATA    00,2B,00
018E8:  DATA    2C,00,2D
018EA:  DATA    00,2E,00
018EC:  DATA    30,00,31
018EE:  DATA    00,32,00
018F0:  DATA    33,00,35
018F2:  DATA    00,36,00
018F4:  DATA    37,00,38
018F6:  DATA    00,3A,00
018F8:  DATA    3B,00,3C
018FA:  DATA    00,3E,00
018FC:  DATA    3F,00,40
018FE:  DATA    00,42,00
01900:  DATA    43,00,44
01902:  DATA    00,46,00
01904:  DATA    47,00,49
01906:  DATA    00,4A,00
01908:  DATA    4B,00,4D
0190A:  DATA    00,4E,00
0190C:  DATA    50,00,51
0190E:  DATA    00,52,00
01910:  DATA    54,00,55
01912:  DATA    00,57,00
01914:  DATA    58,00,5A
01916:  DATA    00,5B,00
01918:  DATA    5C,00,5E
0191A:  DATA    00,5F,00
0191C:  DATA    61,00,62
0191E:  DATA    00,64,00
01920:  DATA    65,00,66
01922:  DATA    00,68,00
01924:  DATA    69,00,6B
01926:  DATA    00,6C,00
01928:  DATA    6E,00,6F
0192A:  DATA    00,70,00
0192C:  DATA    72,00,73
0192E:  DATA    00,75,00
01930:  DATA    76,00,77
01932:  DATA    00,79,00
01934:  DATA    7A,00,7C
01936:  DATA    00,7D,00
01938:  DATA    7E,00,80
0193A:  DATA    00,81,00
0193C:  DATA    82,00,83
0193E:  DATA    00,85,00
01940:  DATA    86,00,87
01942:  DATA    00,89,00
01944:  DATA    8A,00,8B
01946:  DATA    00,8C,00
01948:  DATA    8D,00,8F
0194A:  DATA    00,90,00
0194C:  DATA    91,00,92
0194E:  DATA    00,93,00
01950:  DATA    94,00,96
01952:  DATA    00,97,00
01954:  DATA    98,00,99
01956:  DATA    00,9A,00
01958:  DATA    9B,00,9C
0195A:  DATA    00,9D,00
0195C:  DATA    9E,00,9F
0195E:  DATA    00,A0,00
01960:  DATA    A0,00,A1
01962:  DATA    00,A2,00
01964:  DATA    A3,00,A4
01966:  DATA    00,A5,00
01968:  DATA    A5,00,A6
0196A:  DATA    00,A7,00
0196C:  DATA    A8,00,A8
0196E:  DATA    00,A9,00
01970:  DATA    AA,00,AA
01972:  DATA    00,AB,00
01974:  DATA    AB,00,AC
01976:  DATA    00,AC,00
01978:  DATA    AD,00,AD
0197A:  DATA    00,AE,00
0197C:  DATA    AE,00,AF
0197E:  DATA    00,AF,00
01980:  DATA    AF,00,B0
01982:  DATA    00,B0,00
01984:  DATA    B0,00,B0
01986:  DATA    00,B1,00
01988:  DATA    B1,00,B1
0198A:  DATA    00,B1,00
0198C:  DATA    B1,00,B1
0198E:  DATA    00,B1,00
01990:  DATA    B2,00,B2
01992:  DATA    00,B2,00
01994:  DATA    B1,00,B1
01996:  DATA    00,B1,00
01998:  DATA    B1,00,B1
0199A:  DATA    00,B1,00
0199C:  DATA    B1,00,B0
0199E:  DATA    00,B0,00
019A0:  DATA    B0,00,B0
019A2:  DATA    00,AF,00
019A4:  DATA    AF,00,AF
019A6:  DATA    00,AE,00
019A8:  DATA    AE,00,AD
019AA:  DATA    00,AD,00
019AC:  DATA    AC,00,AC
019AE:  DATA    00,AB,00
019B0:  DATA    AB,00,AA
019B2:  DATA    00,AA,00
019B4:  DATA    A9,00,A8
019B6:  DATA    00,A8,00
019B8:  DATA    A7,00,A6
019BA:  DATA    00,A5,00
019BC:  DATA    A5,00,A4
019BE:  DATA    00,A3,00
019C0:  DATA    A2,00,A1
019C2:  DATA    00,A0,00
019C4:  DATA    A0,00,9F
019C6:  DATA    00,9E,00
019C8:  DATA    9D,00,9C
019CA:  DATA    00,9B,00
019CC:  DATA    9A,00,99
019CE:  DATA    00,98,00
019D0:  DATA    97,00,96
019D2:  DATA    00,94,00
019D4:  DATA    93,00,92
019D6:  DATA    00,91,00
019D8:  DATA    90,00,8F
019DA:  DATA    00,8D,00
019DC:  DATA    8C,00,8B
019DE:  DATA    00,8A,00
019E0:  DATA    89,00,87
019E2:  DATA    00,86,00
019E4:  DATA    85,00,83
019E6:  DATA    00,82,00
019E8:  DATA    81,00,80
019EA:  DATA    00,7E,00
019EC:  DATA    7D,00,7C
019EE:  DATA    00,7A,00
019F0:  DATA    79,00,77
019F2:  DATA    00,76,00
019F4:  DATA    75,00,73
019F6:  DATA    00,72,00
019F8:  DATA    70,00,6F
019FA:  DATA    00,6E,00
019FC:  DATA    6C,00,6B
019FE:  DATA    00,69,00
01A00:  DATA    68,00,66
01A02:  DATA    00,65,00
01A04:  DATA    64,00,62
01A06:  DATA    00,61,00
01A08:  DATA    5F,00,5E
01A0A:  DATA    00,5C,00
01A0C:  DATA    5B,00,5A
01A0E:  DATA    00,58,00
01A10:  DATA    57,00,55
01A12:  DATA    00,54,00
01A14:  DATA    52,00,51
01A16:  DATA    00,50,00
01A18:  DATA    4E,00,4D
01A1A:  DATA    00,4B,00
01A1C:  DATA    4A,00,49
01A1E:  DATA    00,47,00
01A20:  DATA    46,00,44
01A22:  DATA    00,43,00
01A24:  DATA    42,00,40
01A26:  DATA    00,3F,00
01A28:  DATA    3E,00,3C
01A2A:  DATA    00,3B,00
01A2C:  DATA    3A,00,38
01A2E:  DATA    00,37,00
01A30:  DATA    36,00,35
01A32:  DATA    00,33,00
01A34:  DATA    32,00,31
01A36:  DATA    00,30,00
01A38:  DATA    2E,00,2D
01A3A:  DATA    00,2C,00
01A3C:  DATA    2B,00,2A
01A3E:  DATA    00,28,00
01A40:  DATA    27,00,26
01A42:  DATA    00,25,00
01A44:  DATA    24,00,23
01A46:  DATA    00,22,00
01A48:  DATA    21,00,20
01A4A:  DATA    00,1F,00
01A4C:  DATA    1E,00,1D
01A4E:  DATA    00,1C,00
01A50:  DATA    1B,00,1A
01A52:  DATA    00,19,00
01A54:  DATA    18,00,17
01A56:  DATA    00,16,00
01A58:  DATA    15,00,14
01A5A:  DATA    00,13,00
01A5C:  DATA    12,00,12
01A5E:  DATA    00,11,00
01A60:  DATA    10,00,0F
01A62:  DATA    00,0E,00
01A64:  DATA    0E,00,0D
01A66:  DATA    00,0C,00
01A68:  DATA    0B,00,0B
01A6A:  DATA    00,0A,00
01A6C:  DATA    09,00,09
01A6E:  DATA    00,08,00
01A70:  DATA    08,00,07
01A72:  DATA    00,06,00
01A74:  DATA    06,00,05
01A76:  DATA    00,05,00
01A78:  DATA    04,00,04
01A7A:  DATA    00,03,00
01A7C:  DATA    03,00,02
01A7E:  DATA    00,02,00
01A80:  DATA    01,00,01
01A82:  DATA    40,07,00
01A84:  DATA    40,04,FF
01A86:  DATA    00,7E,FE
01A88:  DATA    FF,FE,FF
01A8A:  DATA    FE,FF,FD
01A8C:  DATA    FF,FD,FF
01A8E:  DATA    FD,FF,FD
01A90:  DATA    FF,FC,FF
01A92:  DATA    FC,FF,FC
01A94:  DATA    FF,FC,FF
01A96:  DATA    FB,FF,FB
01A98:  DATA    FF,FB,FF
01A9A:  DATA    FB,FF,FB
01A9C:  DATA    FF,FA,FF
01A9E:  DATA    FA,FF,FA
01AA0:  DATA    FF,FA,FF
01AA2:  DATA    FA,FF,FA
01AA4:  DATA    FF,FA,FF
01AA6:  DATA    F9,FF,F9
01AA8:  DATA    FF,F9,FF
01AAA:  DATA    F9,FF,F9
01AAC:  DATA    FF,F9,FF
01AAE:  DATA    F9,FF,F9
01AB0:  DATA    FF,F9,FF
01AB2:  DATA    F9,FF,F9
01AB4:  DATA    FF,F9,FF
01AB6:  DATA    F9,FF,F9
01AB8:  DATA    FF,F9,FF
01ABA:  DATA    F9,FF,F9
01ABC:  DATA    FF,F9,FF
01ABE:  DATA    F9,FF,F9
01AC0:  DATA    FF,F9,FF
01AC2:  DATA    F9,FF,F9
01AC4:  DATA    FF,F9,FF
01AC6:  DATA    F9,FF,F9
01AC8:  DATA    FF,F9,FF
01ACA:  DATA    FA,FF,FA
01ACC:  DATA    FF,FA,FF
01ACE:  DATA    FA,FF,FA
01AD0:  DATA    FF,FA,FF
01AD2:  DATA    FA,FF,FA
01AD4:  DATA    FF,FA,FF
01AD6:  DATA    FA,FF,FA
01AD8:  DATA    FF,FB,FF
01ADA:  DATA    FB,FF,00
01ADC:  DATA    00,00,00
01ADE:  INC     W2,W2
01AE0:  CP      W2,#1
01AE2:  BRA     NZ,1AEC
01AE4:  TBLRDL  [W1],W3
01AE6:  TBLRDH  [W1++],W4
01AE8:  MOV.B   6,W0L
01AEA:  RETURN  
01AEC:  CP      W2,#2
01AEE:  BRA     NZ,1AF4
01AF0:  MOV.B   7,W0L
01AF2:  RETURN  
01AF4:  MOV.B   8,W0L
01AF6:  CLR     W2
01AF8:  RETURN  
01AFA:  MOV     #0,W6
01AFC:  MOV     #0,W0
01AFE:  MOV     W0,54
01B00:  MOV     #1842,W0
01B02:  MOV     W0,W1
01B04:  CLR     W2
01B06:  CALL    1ADE
01B0A:  MOV.B   W0L,B
01B0C:  CALL    1ADE
01B10:  MOV.B   W0L,A
01B12:  CP0     W5
01B14:  BRA     Z,1B48
01B16:  BTSS    W5.F
01B18:  BRA     1B28
01B1A:  CALL    1ADE
01B1E:  MOV.B   W0L,D
01B20:  CALL    1ADE
01B24:  MOV.B   W0L,C
01B26:  BCLR    W5.F
01B28:  BTSS    W5.E
01B2A:  BRA     1B3C
01B2C:  BCLR    W5.E
01B2E:  DEC     W5,W5
01B30:  CALL    1ADE
01B34:  MOV.B   W0L,W7L
01B36:  REPEAT  W5
01B38:  MOV.B   W7L,[W6++]
01B3A:  BRA     1B06
01B3C:  CALL    1ADE
01B40:  MOV.B   W0L,[W6++]
01B42:  DEC     W5,W5
01B44:  BRA     NZ,1B3C
01B46:  BRA     1B06
.................... { 
.................... //write_extended_ram(1,0x100,&Weight,8); 
.................... #asm 
....................     BCLR 0x44, #5 
01B48:  BCLR.B  44.5
....................     BSET 0x44, #0 
01B4A:  BSET.B  44.0
....................     BSET 0x44, #13 
01B4C:  BSET.B  45.5
....................     BCLR 0x44, #12 
01B4E:  BCLR.B  45.4
.................... #endasm 
....................     output_high(PIN_F3); 
01B50:  BCLR.B  E50.3
01B52:  BSET.B  E54.3
....................     output_high(PIN_B1); 
01B54:  BCLR.B  E10.1
01B56:  BSET.B  E14.1
.................... #ifndef SIMULATOR 
....................     usb_cdc_init(); 
....................     usb_init(); 
....................     AdasInit(); 
.................... #endif 
....................     output_high(PIN_B0); 
01B58:  BCLR.B  E10.0
01B5A:  BSET.B  E14.0
....................     int looper=0; 
....................     uint16 period=FILTER_ORDER; 
....................     uint16 sample = FILTER_ORDER; 
01B5C:  MOV     #0,W4
01B5E:  MOV     W4,41EC
01B60:  MOV     #1F1,W4
01B62:  MOV     W4,41EE
01B64:  MOV     #1F1,W4
01B66:  MOV     W4,41F0
....................     for(looper=0;looper<FILTER_ORDER;looper++) 
01B68:  MOV     #0,W4
01B6A:  MOV     W4,41EC
01B6C:  MOV     41EC,W0
01B6E:  MOV     #1F1,W4
01B70:  CP      W4,W0
01B72:  BRA     LE,1B96
....................     { 
....................         //BufferForWeight[looper]=1000+1000*sin(2*PI/period*looper); 
....................         FilterBufferCh11[looper]=0x07ffff; 
01B74:  MOV     41EC,W0
01B76:  MOV     W0,W4
01B78:  MUL.UU  W4,#4,W0
01B7A:  MOV     #1260,W4
01B7C:  ADD     W0,W4,W5
01B7E:  SETM.B  [W5]
01B80:  MOV.B   #FF,W0L
01B82:  MOV.B   W0L,[W5+#1]
01B84:  MOV.B   #7,W0L
01B86:  MOV.B   W0L,[W5+#2]
01B88:  MOV.B   #0,W0L
01B8A:  MOV.B   W0L,[W5+#3]
01B8C:  MOV     41EC,W0
01B8E:  INC     W0,W0
01B90:  MOV     W0,41EC
01B92:  GOTO    1B6C
....................         //Weight[looper]=0x7fff; 
....................     } 
....................     unsigned long Size=8192; 
01B96:  MOV     #2000,W4
01B98:  MOV     W4,41F2
01B9A:  MOV     #0,W4
01B9C:  MOV     W4,41F4
....................     ruBufferTester(); 
01B9E:  CALL    1492
....................     Size=8192; 
01BA2:  MOV     #2000,W4
01BA4:  MOV     W4,41F2
01BA6:  MOV     #0,W4
01BA8:  MOV     W4,41F4
....................     Message.Header.Start='S'; 
01BAA:  MOV     21E8,W0
01BAC:  MOV.B   #53,W0L
01BAE:  MOV     W0,21E8
....................     Message.Header.Sign=0x02; 
01BB0:  MOV     21E8,W0
01BB2:  SWAP    W0
01BB4:  MOV.B   #2,W0L
01BB6:  SWAP    W0
01BB8:  MOV     W0,21E8
....................     Message.Header.Size1=Size>>8; 
01BBA:  PUSH    41F2
01BBC:  MOV     [--W15],W0
01BBE:  LSR     W0,#8,W0
01BC0:  PUSH    21EA
01BC2:  MOV.B   W0L,[W15-#2]
01BC4:  POP     21EA
....................     Message.Header.Size2=Size; 
01BC6:  MOV     41F2,W0
01BC8:  PUSH    21EA
01BCA:  MOV.B   W0L,[W15-#1]
01BCC:  POP     21EA
....................     while(1) 
....................     { 
.................... #ifndef SIMULATOR 
....................         ruUsb(); 
....................         ruUsbInputProcess(); 
.................... #endif 
....................         ruAdasHandler(); 
01BCE:  CALL    16D0
01BD2:  GOTO    1BCE
....................         //if(UsbState == USB_SENDING) output_toggle(PIN_B0); 
....................     } 
....................     return (1); 
01BD6:  MOV     #1,W4
01BD8:  MOV     W4,0
.................... } 
01BDA:  PWRSAV  #0

Configuration Fuses:
   Word  3L: 0003   NOWRT NOPROTECT NOGSSK
          H: 0000  
   Word  4L: 0080   FRC IESO
          H: 0000  
   Word  5L: 0022   HS OSCIO IOL1WAY CKSFSM
          H: 0000  
   Word  6L: 007F   WPOSTS16 WPRES128 PLLWAIT WINDIS NOWDT
          H: 0000  
   Word  7L: 0037   PUT128 NOBROWNOUT NOALTI2C1
          H: 0000  
   Word  8L: 00D7   ICSP1 RESET_PRIMARY NOJTAG NODEBUG
          H: 0000  
   Word  9L: 0003   NOAWRT NOAPROTECT NOAPLK
          H: 0000  
